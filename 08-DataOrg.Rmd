# Data Organization

Let's download some data and look at a dataframe

```{r}
mort <- read.csv("./docs/data/BighornMortTable.csv")
```

If we look at the data, we can see that each column is a specific data type,
and we can index it with the operator.

```{r}
mort$Animal_ID[1]
```

We can use the functions `head()` and `tail()` to look at the first or last 6 rows of the data frame. 

```{r}
head(mort, 3) 
```

Similarly, `[[` will act to extract a single column:
```{r}
mort[["AnimalYear"]][500]
```

We could also use brackets to index specific elements of the dataframe. Remember that when you index a dataframe using square brackets, the order is rows, columns.
```{r}
# [rows, columns]
mort[1,2] # grab element at first row and second column
mort[1,1:6] # grab row 1 in columns 1-6
mort[1:6,5] # grab row 1-6 in column 5
mort[1:6,1:6] # grab row 1-6 in columns 1-6
head(mort[,1:3], 5) # grab all rows from columns 1-3, show me the first 5 rows
```

You can coerce lists to data.frames, assuming they follow the data frame rules.
```{r}
test.list <- list(1, "banana", TRUE)
class(test.list)
my_seq <- as.data.frame(test.list)
class(my_seq)
```

R is a natively vectorized language. Meaning it automatically performs 
vector operations. All of this starts to make sense if you're having trouble 
subsetting with `$` or even `[]` or `[[]]`.

# Exploring Data Frames
Let's check out the data! Data exploration is one of the most important parts of working in R and it's the first thing you should always do when looking at new data!

```{r}
# str() shows us the structure of the data, including the data mode, 
# the dimensions of # the dataframe including the data mode, the dimensions of 
# the dataframe, and a few observations
str(mort)  
length(mort) # gives the number of columns
nrow(mort) # to get the number of rows
ncol(mort) # number of columns
dim(mort) # or both at once, dim()
colnames(mort) # names of the columns
```

It's a good time to ask ourselves if the structure R is reporting matches our intuition:

* Does the data type for each column make sense? 
* If not, we need to sort out those issues now so we 
* Don't run into issues down the road. Once we're happy with our data types, we can really start digging into our data!

We can also examine individual columns: 

```{r}
class(mort$AnimalYear) 
class(mort$Animal_ID)
str(mort$Cause_Mort)
```

## Data Frame Manipulation

Let's create a new column to hold information on whether bighorn age is < 5:

```{r}
below_five <- mort$Age < 5
head(below_five)
```

We've simply created a vector with TRUE/FALSE values; but we can add this to our dataframe using:

```{r}
mort <- cbind(mort, below_five)
head(cbind(mort, below_five), 3)
head(mort, 3)
```


Note that if we try to add a vector of below_average with a different number of entries then the number of rows in our data frame, it would fail:

```{r error=FALSE, eval=FALSE}
below_five <- c(TRUE, TRUE, TRUE, TRUE, TRUE)
head(cbind(mort, below_five))
```

The sequence TRUE,TRUE,FALSE is repeated over all the gapminder rows. Letâ€™s overwite the content of gapminder with our new data frame.

```{r}
below_five <-  as.logical(mort$Age<5)
gapminder <- cbind(mort, below_five)
```

How about adding rows?
```{r error=FALSE, eval=FALSE}
# first let's make a mortality dataframe of 3 columns
mort_short <- mort[,c("Animal_ID", "Age", "Cause_Mort")]
new_row <- list('S781', 3, "Lion") 
# note that we have to make the row a list, since each column has a different data type
mort_new <- rbind(mort_short, new_row)
tail(mort_new) # lets you look at the last 6 lines of data
```
