# Using R

## Use R as a calculator

Remember, order of operations matters. The order is the same as you learned back in school.
  
From highest to lowest precedence:
  
- Parentheses: `(`, `)`
- Exponents: `^` or `**`
- Divide: `/`
- Multiply: `*`
- Add: `+`
- Subtract: `-`

```{r eval=TRUE, include=TRUE}
1 + 100
3 + 5 * 2 # performs multiplication before addition
(3 + 5) * 2 # performs addition in () before multiplication 
2/10000 
2^3 # text after a code line is called a "comment"
```

## Use R to compare things
To compare things in R, we use logical operators. Below is a brief list. 

Summary of logical operators
`==`    is equal to
`>`     greater than
`<`     less than
`>=`    greater than or equal
`<=`    less than or equal
`!`     not
`|`     or
`%in%`  is contained

```{r}
1 == 9  # equality (note two equals signs, read as "is equal to")
1 != 1  # inequality (read as "is not equal to")
1 < 2  # less than
1 <= 1  # less than or equal to
```
Notice how R evaluates each of these lines of code as TRUE or FALSE. We are essentially asking R if the above comparison is TRUE or FALSE.

## Use R to assign objects

Objects are a bit of an abstract concept. All you really need to know for now is that objects are things that we make in R that can take on a variety of structures with different data types, and when we assign them a name, they get saved in our global environment. They are data structures with associated data attributes. 

Object assignment allows us to assign a variable name to the object for later use. This helps prevent writing redundant code. We assign an object to a variable using the assignment arrow `<-` or the `=` so that R knows that x is an object that we can use. So when we run, x <- 6, it reads "make x contain 6." It's recommended to use the `<-` since the `=` can get mixed up with assigning values to function arguments (more on this later). Once we assign an object to a variable, it is stored in our global environment (upper right hand panel of R studio).

```{r}
x <- 1/40 # here we are telling R to assign 1/40 to the variable x so that it recognizes x as an object in our global environment
x 
x = 24 # variables can easily be re-assigned/over-written
y <- x * 2

rm(y) # you can also remove objects from the environment
```

### Variable names
Variable names can contain letters, numbers, underscores and periods. 
They CANNOT start with a number OR contain spaces (**at all**). Remember that R is case sensitive.

A few different conventions for longer variable names:

- periods.between.words
- underscores_between_words
- camelCaseToSeparateWords

Your choice of convention is up to you, *JUST BE CONSISTENT*.

## Data Types (Modes)

Below are 6 main classes of common data types: `numeric`, `integer`, `complex`, `logical`, `character`, and `factor`

```{r eval=FALSE}
class(1.11) # numeric: any real number
class(1L) # integer: any integer. The L suffix forces the number to be an integer
class(TRUE) # logical: binary TRUE or FALSE 
# You can have data that look essentially the same, but have different classes. 
class('1') # character: words; "" denote words
class(1) # numeric; any real number
class(factor("1a")) # factor: denotes categorical variables, they can be words or numbers
```

You can coerce to a desired data type, as long as they follow the rules
using the functions as.<desired data type>

Hierarchy from general to specific: Logical -> Numeric -> Character

1. logical (least general, cannot turn turn character or numeric into a logical type without correctly specifying the value)
2. numeric (can read integer and logical types as numbers)
3. character (most general: anything can be turned into a character by adding "quotes")

```{r}
# Convert from numeric to integer
a <- 45.6
class(a)
# Convert from numeric to character
a_character <- as.character(a)
class(a_character)
```

80% of the time when something isn't running, it's because the data isn't the right type. In the example below, we throw an error because R cannot make a character class into a numeric class. All columns in a data frame need to be the same type as well.
```{r}
# convert from character to numeric
b <- "banana"
b_numeric <- as.numeric(b)
```

## Data Structure Classes

Remember earlier when we talked about objects as data with attributes? 
Well, there are many different ways to store data. The most common ways are in vectors, data frames, and lists. 

### Scalar
A vector has one element with length 1. 
```{r}
x <- 3
```

### Vector
A vector in R is essentially a collection of items **of the same basic 
data type**. Each 'thing' in the vector is called an element. If you don’t 
choose the data type, it’ll default to logical; or, you can declare an 
empty vector of whatever type you like. You can also make vectors with 
explicit contents using the concatenate function `c()`.

## Lists
A list in R is essentially an object with data that can be in different data types/modes.

```{r}
# list with numeric, character, and logical classes
my_list <- list(1, "banana", TRUE)
your_list <- list(2, "apple", FALSE)
my_list
```

The `$` is called the operator, and it is used for indexing named elements in a list. It allows you to access part of a data object for extracting or subsetting data.

```{r}
names(my_list) <- c("x", "y", "z")
my_list$x
```

If you wanted to index a specific element in the list, you could also use brackets
```{r}
# combine two vectors into a list
big_list <- list(your_list, my_list)
big_list

# index second list [[2]] and second element [2] of second list
big_list[[2]][2]
```

## Data Frames
A data frame in R is a like a list or generalized matrix but with the constraints that:

(1) all list elements are vectors (i.e. they have 1 mode), 
(2) all vectors have the same length
(3) all columns (the list elements) have names

Essentially, imagine each column in the dataframe as a vector, and the dataframe is just a big list of all those vectors. Unlike actual lists however, in dataframes all of the columns/vectors MUST be the same length and have names.

## Playing with different data types
Let's mess with some vectors:

```{r}
my_vector <- vector(length = 3)
my_vector  # this is a logical vector
num_vector <- c(1, 2, 3, 4, 5) # numeric vector
# what happens when we add elements of different data types to a vector?
combine_vector <- c(2, "banana", TRUE)
combine_vector
class(combine_vector) 
```
R interprets the whole vector as character. It can't make "banana" into a number but it can turn 2 and TRUE into text strings. 

You can also assign NA values to a vector of defined length as well. # R is able to handle missing values, and these missing values are given NA. When
you read in an csv file with empty cells, R will assign these values as NA. A 0 
is not the same as NA, since R treats 0 as a numeric data class.   

```{r}
x <- rep(NA, 10)
x[1] <- 0
# test if zero is NA
is.na(x)
```

The concatenate function `c()` will also append an existing vector or create a list...

```{r}
# cm
ab <- c('a', 'b')
ab
c <- c(ab, 'DC', "EF")
c
```

Or we can make a series of numbers...
```{r}
my_series <- 1:10 # just integers
my_series
# make series of numbers from 1 to 10 by increments of 0.1
my_seq <- seq(from = 1, to = 10, by = 0.1) 
my_seq
```

## Functions
We used the function seq() above to make a series of numbers. So what is a function? A function is a defined script that is used to accomplish a particular task. Functions use an input to give a desired output. Every function has arguments that determine what kind of inputs are needed to make the function run. The inputs in a function are called arguments.

* Arguments: information that goes inside the parenthesis to tell the function what to do. For example, when we used the `seq` function above, the arguments are `from = 1`, `to = 10`, and `by = 0.1`.
* Pass: We pass a value to a function argument. Above, we pass the value 1 to the argument `from`, and the value 10 to the argument `to` and the value 0.1 to the argument `by`
* Return: This is the terminology to say that the function gives us a an output. So with the `seq(from = 1, to = 10, by = 0.1)`, the function <em>returns</em> a sequence of numbers

 The order that we put the arguments into the function matters. It can be helpful to define the arguments in the function. You can use the help function to ensure that your arguments are correct.
`?seq`

## Indexing

So now that we’ve created dummy vectors to play with, how do we get at its contents?

To extract elements of a vector we can give their corresponding index (square brackets `[]` are used for indexing). R uses 1-based indexing, so the
first element of a vector, list, or dataframe is accessed using the index 1 (Python and C use 0-based indexing).

```{r}
my_seq[1] # extract first element out of the my_seq vector
my_series[4] # extract 4th element out of the my_series vector
my_seq[c(2:4)] # extract elements 2 to 4 from the my_seq vector
```

We can also extract elements by using their name instead of extracting by index. Names are another attribute that you can give to data. They are often useful so that you don't have to type out a lot of numbers.

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5) # create vector
names(x) <- c("a", "b", "c", "d", "e") # assign names to vector
# we can also name a vector 'on the fly'
x <- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) 
x[c("a", "c")]
```

Since comparison operators (e.g. >, <, ==) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one.

```{r}
x[x > 7] # this statement first evaluates x>7, generating a logical vector 
# c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of x 
# corresponding to the TRUE values.
```

If we use a negative number as the index of a vector, R will return every element except for the one specified:

```{r}
x[-2]
# we can skip multiple elements
x[c(-1, -5)]  
# or 
x[-c(1,5)]
# a common mistake would be to ask R x[-1:3] # but there isn't a negative first row
# But remember the order of operations. 
# : is really a function. It takes its first argument as -1, 
# and its second as 3, so generates the sequence of 
# numbers: c(-1, 0, 1, 2, 3).
x[-(1:3)]
# To remove elements from a vector, we need to assign the result 
# back into the variable:
x <- x[-4]
x
```



