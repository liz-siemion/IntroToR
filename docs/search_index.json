[["index.html", "CDFW Introduction to R Programming Chapter 1 Overview 1.1 Workshop Goals 1.2 Workshop Content", " CDFW Introduction to R Programming Liz Siemion 2025-05-14 Chapter 1 Overview I reference course materials from USU’s ecology center workshop, and Dr. Simona Picardi’s Reproducible data science website. 1.1 Workshop Goals This course is designed to teach the foundational programming concepts of R and how to use RStudio. Our goal is to equip you with the skills to continue learning R independently and to integrate R programming into your analyses and workflows. Artwork by Allison Horst 1.2 Workshop Content Intro to R and R-Studio Directory Structure File paths Packages Working with R objects Data types (character, numeric, logical, etc.) and classes (scalar, vector, data frames, matrices, lists, etc.) Functions (arguments, function workflow) Indexing Importing and exporting data files (csv, xlsx, mdb, rds)] Data organization and manipulation (base R and tidyverse) Basic plotting Tidy Data For-loops 14 Basic statistics &amp; statistical summaries Introduction to debugging (how to ask the right questions) Making readable R code (commenting, outlining, etc.) "],["Intro.html", "Chapter 2 Intro to R and R-Studio 2.1 What is R? 2.2 Directory Structure 2.3 R Studio 2.4 RStudio Projects 2.5 Using Comments", " Chapter 2 Intro to R and R-Studio 2.1 What is R? R is both the name of the programming language and the software used for data storage and manipulation. RStudio is the Integrated Development Environment (IDE) for the R programming language that makes writing, running, and organizing R code more efficient. RStudio provides a centralized interface where you can manage your code, working directory, data, output, and environment all in one place. On my MacBook, I keep R and RStudio in the Applications folder, and on Windows, I store them on the C drive. You will need to download R before downloading RStudio. 2.2 Directory Structure Before creating an RStudio Project, it’s important to think about how your project is structured, as this will shape your directory (i.e. folder) organization. I typically create a separate folder for each analysis, and within each, I include subfolders for data, output, and scripts. Other folders might include figures, results, and documents. You may want to consider housing two projects in the same directory if they utilize the same data. All files need to be readable by the computer and should not contain white spaces, punctuation, or special characters. I generally follow the same naming conventions for my files (e.g., camelCase, snake_case, kebab-case, PascalCase). After setting up your directory structure, the next step is to create an RStudio Project in R Studio. EXERCISE 1: CREATING A WORKING DIRECTORY Create a new working directory named IntroR. You can put this folder in whichever location makes sense for you on your computer. Create subfolders named data, output, and scripts 2.3 R Studio First let’s go over the basics of RStudio. When you first open RStudio, you will be greeted by three panels: The Interactive R Console (entire left) R scripts appear in the top left. This is where you write your code. When you execute this code, it appears in the Console (bottom left). You can run code from the console, but it will be erased once you close R (unless you save your R history). It’s best to write a saveable script in the code editor where you can send lines of code to the console to be executed. Environment/History (tabbed in upper right) Environment: collection of objects (i.e. variables, data frames, functions, etc.) that we define during our R session History: this contains every line of code executed during the session Files/Plots/Packages/Help/Viewer (tabbed in lower right) Files shows all the files in your working directory. A working directory is essentially the default folder that R is reading data from/putting output into. We will go through setting the working directory below. You can also create, delete, and rename files and folders from this tab. Plots displays figures that you generate Packages displays any packages you have downloaded and installed in R. If there is a check mark next to a package, it means you’ve loaded it into your current R session Help will show you a description of functions. To get a function description, simply run ? followed by the function name. For example, ?setwd() will show me the documentation for the setwd() function. Viewer displays interactive or web-based content Presentation displays slide-style documents created using R Markdown 2.4 RStudio Projects Now that we understand the basics of RStudio, let’s create an RStudio Project that will live in the directory folder of the analysis. RStudio Projects are a self-contained, portable work space where you can have your data, code, and output all in one place. RStudio Projects are also great to use for reproducibility because they are self-contained and easy to share with collaborators. This means you can compress the entire RStudio Project into a ZIP file and share it with a collaborator, who should then be able to run your code and reproduce the same results. Let’s go through how to set up an RStudio Project. Steps for Making an RProject Open the File menu from the upper left. Select Existing Directory since we have already set up our project’s directory Navigate to the directory folder Select Create Project Each time you open this RStudio project, the working directory will automatically be set to the IntroR folder. The working directory is automatically set to the folder where your RStudio Project is stored. RStudio Projects remove the need to manually set the working directory. For example, if my RStudio Project is located in C:/Teaching/IntroR/, my working directory is also located C:/Teaching/IntroR/. EXERCISE 2: CREATE AN RSTUDIO PROJECT Create an RStudio PRoject using the instructions above. 2.5 Using Comments Use the # to tell R you are making a comment. Comments are used to explain code and allow someone unfamiliar with your code to follow more easily. Commenting can also be used to prevent R from running specific lines of code since R ignores anything that follows the # mark. # 567*5 tells R that 567*5 is a comment, and so R knows not to execute this line of code. Sometimes you want to comment out large sections of code, and this can be done using control + shift + c on windows or command + shift + c on a macbook. EXERCISE 3: USING COMMENTS Create a new script (File &gt; New File &gt; R Script) In the first line, type # Intro R On line 2, type 1 + 1 select Run in the upper right corner of the console "],["FilePaths.html", "Chapter 3 File paths 3.1 What is a file path? 3.2 Different separators between operating systems 3.3 Absolute and Relative file paths 3.4 Navigating outside the working directory 3.5 Useing the Tab Shortcut in RStudio", " Chapter 3 File paths To manually set the working directory or load a file from a specific location, it’s important to understand how file paths work. 3.1 What is a file path? File paths are addresses to different locations or files on a computer. Your computer uses a system of nested folders. Nested file system on your computer – image from R for epidemiology (https://www.r4epi.com) File paths are addresses to different locations or files within this nested framework. They represents the order of nested folders that the computer must go through to find that particular item. Each folder is separated by a slash. We can use Absolute or Relative file paths in R to locate files. Knowing the file path is important when you need to set your working directory. See this website for a detailed explanation. 3.2 Different separators between operating systems Different operating systems use different separators between folders of a file path. On windows, it is \\ On Mac/Linux, it is / R uses the / separator, so in windows, remember to either use a backward slash \\\\ or change all \\ to / between your folders of your file path. 3.3 Absolute and Relative file paths We can use Absolute or Relative file paths to give R directions to where we want to go. Absolute Paths: describe where a file is located relative to the root directory of the computer. This can be done on windows through right clicking the file path in windows explorer and selecting copy as text, or right clicking a file, holding the option key and selecting copy as path name on a macbook. Windows example: C:/Users/Documents/Teaching/IntroR/data/Intro-to-R-Workshop.csv Macbook example: /Users/lizsiemion/Documents/Teaching/IntroR/Intro-to-R-Workshop.csv Relative Paths: describe file location with respect to the current working directory. This just means that the file path starts with the location of the home directory. Windows example: IntroR/data/Intro-to-R-Workshop.csv Macbook example: IntroR/data/Intro-to-R-Workshop.csv ) It can be a bit cumbersome to work with absolute file paths. Since R Projects automatically sets the working directory as the project folder, we can use relative paths without any sort of additional set-up. Using relative paths also makes our code more readable, and easier to share and maintain. If we want to set our working directory manually, we can either use absolute or relative file paths. I recommend not changing the working directory within your script, as this can limit reproducibility. # check working directory getwd() # Assign working directory to new location using absolute path setwd(&quot;/Users/lizsiemion/Documents/teaching/Intro-to-R-Workshop&quot;) # Again, I do not recommend changing the working directory from an R project. 3.4 Navigating outside the working directory Let’s say we want to load a csv file into R that is outside of our working directory subfolders. How might we do that with absolute or relative paths from our current working directory? The absolute path is the full file path from our computer’s root directory. If we want to use the relative path, we need tell R to go up a given number of parent folder levels from a working directory, and then to the given location within that parent folder. This can be accomplished using ../ syntax. ./ tells R to go to the folder of the working directory ../ tells R to go to the parent folder of the working directory ../../ tells R to go to the parent folder of the parent folder of the working directory Let’s look at an example. Say our folder structure resembles the structure below and our RProject is located in the Intro-to-R-Workshop folder. Step 1: How many parent levels do we need to move up? Looks like we need to move up 1 level to the teaching folder ../, and another level up to the Documents folder ../. Step 2: Now that we are in the Documents folder, what is the relative path to to the example_file.txt? We need to go into the Coursework folder, and then the EcologyCenter folder, where example_file.txt is ultimately located. Coursework/EC-tidyverse-workshop-main/example_file.txt By combining steps 1 and 2, we’ve create the relative file path and can load the example_file.txt into our environment with read.csv(). read.csv(\"../../Coursework/ecologycenter/example_file.txt\") 3.5 Useing the Tab Shortcut in RStudio The Tab shortcut in RStudio is a powerful shortcut that helps you write code faster and with fewer errors. It’s especially helpful for auto-completing file paths, function names, object names, and more. When you’re loading a file (e.g., using read.csv()), you can use the Tab key to help you find and insert the correct relative file path. For example: read.csv(\"data/ Then press the Tab key. A drop down list will appear showing the contents of the data/ folder (if it exists). You can then use the arrow keys to select a file and select Enter to insert it into the code. The Tab key shortcut helps avoid typos and ensures you’re referencing the correct file. EXERCISE 1: FILE PATHS Type `getwd() into the console to return the absolute file path Use a relative file path to load the bighorn capture table using read.csv(“TYPE_RELATIVE_FILE_PATH”). The read.csv() function tells R to load the CSV file into your Environment. Make sure the file path is placed inside quotes and within the parentheses. Tip: Try using the Tab key after typing the opening quote to help you navigate and generate the correct relative file path. "],["TidyData.html", "Chapter 4 Tidy Data 4.1 Spreadsheets and Database Tables 4.2 Computer Readable Data 4.3 Tidy Data 4.4 Document 4.5 Rows for variables, columns for observations 4.6 Problemmatic Practices", " Chapter 4 Tidy Data 4.1 Spreadsheets and Database Tables 4.2 Computer Readable Data 4.3 Tidy Data Illustrations from the Openscapes blog Tidy Data for reproducibility, efficiency, and collaboration by Julia Lowndes and Allison Horst 4.4 Document 4.5 Rows for variables, columns for observations 4.6 Problemmatic Practices 4.6.1 Multiple tables in a single spreadsheet 4.6.2 Putting units in cells 4.6.3 Using Problematic Column Names 4.6.4 Zeros vs Missing Values 4.6.5 Using Problematic Null Values 4.6.6 Inconsistent Value Formatting "],["using-r.html", "Chapter 5 Using R 5.1 Installing Packages 5.2 Use R as a calculator 5.3 Use R to compare things 5.4 Use R to assign objects 5.5 Data Types (Modes) 5.6 Data Structure Classes 5.7 Functions 5.8 Indexing", " Chapter 5 Using R 5.1 Installing Packages Sometimes you will want to use tools that are not built into the baseR code. You can download these tools from R repositories as packages. A package is a collection of functions, data, and documentation bundled together for a specific function. An R package can help with data visualization, statistical modeling, or data cleaning. You can install an R package through the RStudio interface, or through entering code into the console install.packages(&quot;amt&quot;) # install a new package library(amt) # call a package you previously downloaded EXERCISE 4: LOAD TIDYVERSE PACKAGE USING RSTUDIO Select Packages Select Install Type tidyverse Select Install Bonus: Install tidyverse in the code editor using the example code above. We will go over what tidyverse is later on in this course If two different packages contain functions with the same name, R will mask one with the other based on the order they are loaded. To avoid confusion, you can explicitly tell R which package to use by using the package::function() format. For example, the filter() function exists in both stats and dplyr packages. If you specifically want the version from dplyr, you can write dplyr::filter() in your code. We will talk more about this later on. 5.2 Use R as a calculator Remember, order of operations matters. The order is the same as you learned back in school. From highest to lowest precedence: Operator Symbol(s) Description Parentheses ( ) Controls the order of operations Exponents ^, ** Raises a number to a power Divide / Division Multiply * Multiplication Add + Addition Subtract - Subtraction 1 + 100 ## [1] 101 3 + 5 * 2 # performs multiplication before addition ## [1] 13 (3 + 5) * 2 # performs addition in () before multiplication ## [1] 16 2/10000 ## [1] 2e-04 2^3 # text after a code line is called a &quot;comment&quot; ## [1] 8 5.3 Use R to compare things To compare things in R, we use logical operators. Below is a brief list. Summary of logical operators == is equal to &gt; greater than &lt; less than &gt;= greater than or equal &lt;= less than or equal ! not | or %in% is contained 1 == 9 # equality (note two equals signs, read as &quot;is equal to&quot;) ## [1] FALSE 1 != 1 # inequality (read as &quot;is not equal to&quot;) ## [1] FALSE 1 &lt; 2 # less than ## [1] TRUE 1 &lt;= 1 # less than or equal to ## [1] TRUE Notice how R evaluates each of these lines of code as TRUE or FALSE. We are essentially asking R if the above comparison is TRUE or FALSE. EXCERCIZE 1 In your code editor, write the following lines of code. Then execute the lines of code so you see the output in your console. 67 * 9 7 + 9 + 10 4399 - 871 * (9 + 1) Bonus: What is wrong with the following code? Type 87(9 + 1) into your console Execute that specific line of code by placing the cursor on that line and selecting Run. What error do you see? What do you think is happening? How might you fix this? 5.4 Use R to assign objects Objects are a bit of an abstract concept. All you really need to know for now is that objects are things that we make in R that can take on a variety of structures with different data types, and when we assign them a name, they get saved in our global environment. They are data structures with associated data attributes. Object assignment allows us to assign a variable name to the object for later use. This helps prevent writing redundant code. We assign an object to a variable using the assignment arrow &lt;- or the = so that R knows that x is an object that we can use. So when we run, x &lt;- 6, it reads “make x contain 6.” It’s recommended to use the &lt;- since the = can get mixed up with assigning values to function arguments (more on this later). Once we assign an object to a variable, it is stored in our global environment (upper right hand panel of R studio). x &lt;- 1/40 # here we are telling R to assign 1/40 to the variable x so that it recognizes x as an object in our global environment x ## [1] 0.025 x = 24 # variables can easily be re-assigned/over-written y &lt;- x * 2 rm(y) # you can also remove objects from the environment 5.4.1 Variable names Variable names can contain letters, numbers, underscores and periods. They CANNOT start with a number OR contain spaces (at all). Remember that R is case sensitive. A few different conventions for longer variable names: periods.between.words underscores_between_words camelCaseToSeparateWords Your choice of convention is up to you, JUST BE CONSISTENT. EXERCISE 2 Assign 1+56 to a variable called x1_a Assign sqrt(24) to a variable called x1_b Bonus: Chained assignments. What happens when you execute x3.c &lt;- y3.c &lt;- 9/10 into your console? Are x3.c and y3.c different or equal values? 5.5 Data Types (Modes) There are 6 main classes of common data modes (i.e. data types): numeric, character, logical, complex, and raw. Data modes refers to the basic type of data stored in an object. For example, numeric mode stores numbers (integers or decimals), and character mode stores text. We typically only use factor, numeric, character, and logical data modes. Mode Description Example factor Categorical data “Sheep”, “Lion”, “Deer” numeric Numbers (includes integers and decimals) 3.14, 42 character Text strings “Lion180” logical TRUE or FALSE values TRUE, FALSE To ask R what class a data mode or object is, we use the function class(). class(1.11) # numeric: any real number class(1L) # integer: any integer. The L suffix forces the number to be an integer class(TRUE) # logical: binary TRUE or FALSE # You can have data that look essentially the same, but have different classes. class(&#39;1&#39;) # character: words; &quot;&quot; denote words class(1) # numeric; any real number class(factor(&quot;1a&quot;)) # factor: denotes categorical variables, they can be words or numbers You can coerce to a desired data type, as long as they follow the rules using the functions as.&lt;desired data type&gt; Coercian Hierarchy from general to specific: Logical -&gt; Numeric -&gt; Factor -&gt; Character logical (least general, cannot turn turn character or numeric into a logical type without correctly specifying the value) numeric (can read integer and logical types as numbers) character (most general: anything can be turned into a character by adding “quotes”) # Convert from numeric to integer a &lt;- 45.6 class(a) ## [1] &quot;numeric&quot; # Convert from numeric to character a_character &lt;- as.character(a) class(a_character) ## [1] &quot;character&quot; # Create factored variable lion &lt;- factor(c(&quot;194&quot;), levels = c(&quot;194&quot;)) lion # print value into console ## [1] 194 ## Levels: 194 as.numeric(lion) # coerced to numeric ## [1] 1 as.character(lion) # coerced to character ## [1] &quot;194&quot; as.numeric(as.character(lion)) # coerced to character, then numeric ## [1] 194 A common mistake in R is using data of the wrong type. In the example below, an error occurs because R cannot convert a character value into a numeric one. It’s important to ensure that the data you’re working with is of the correct type. Also, remember that each column in a data frame should contain values of the same type. # convert from character to numeric b &lt;- &quot;banana&quot; b_numeric &lt;- as.numeric(b) ## Warning: NAs introduced by coercion EXERCISE 3 Assign \"S437\" to a variable called “sheep”. Make sure to include the \"\". What type of data class is sheep? Create an object with a value of 45. Coerce to a character class using as.character(). Execute S1 &lt;- as.numeric(as.character(1)) and S2 &lt;- as.logical(as.numeric(\"1\")). Do the values change? Why or why not? Think about this answer in the context of the coercian hierarchy. Bonus: What happens when you execute sheep &lt;- S437 without \"\"? Explain the error. 5.6 Data Structure Classes Remember when we talked about objects as data with attributes? Well, R offers several ways to store data, depending on what kind of structure you need. The most common types are vectors, data frames, and lists. Each of these can store different types of information and are useful in different contexts when working with data. Think of them as different types of containers for data that are designed to hold and organize data in specific ways. We will be discussing Scalar, Vector, Data Frames, Matrices, and Lists. Below is a summary of each of these data structures, and we will also go through each of these individually. Data Structure Description Can Contain Different Types? Dimensions Example Scalar A single value (a vector of length 1) No 1 (length = 1) x &lt;- 42 Vector A sequence of elements of the same type No 1 (length &gt; 1) c(1, 2, 3) Data Frame Table-like structure with columns of equal length Yes (by column) 2 (rows × cols) data.frame(a = 1:3, b = c(\"x\", \"y\", \"z\")) Matrix 2D array with all elements of the same type No 2 (rows × cols) matrix(1:6, nrow = 2) List A collection of elements that can be of different types Yes 1 (named or not) list(name = \"A\", age = 25, scores = c(1,2,3)) 5.6.1 Scalar A vector has one element with length 1. x &lt;- 3 5.6.2 Vector A vector in R is essentially a collection of items of the same basic data type. Each ‘thing’ in the vector is called an element. If you don’t choose the data type, it’ll default to logical; or, you can declare an empty vector of whatever type you like. You can also make vectors with explicit contents using the concatenate function c(). my.deer &lt;- c(&quot;GDL256&quot;, &quot;RVD1011&quot;, &quot;CDB567&quot;) my_vector &lt;- vector(length = 3) my_vector # this is a logical vector ## [1] FALSE FALSE FALSE num_vector &lt;- c(101, 222, 323, 435, 556) # numeric vector # what happens when we add elements of different data types to a vector? combine_vector &lt;- c(211, &quot;CDB678&quot;, TRUE) combine_vector ## [1] &quot;211&quot; &quot;CDB678&quot; &quot;TRUE&quot; class(combine_vector) ## [1] &quot;character&quot; R interprets the whole vector as character. It can’t make “banana” into a number but it can turn 2 and TRUE into text strings. This logic follows the coercian hierarchy. You can also assign NA values to a vector of defined length as well. R is able to handle missing values, and these missing values are given NA. When you read in an csv file with empty cells, R will assign these values as NA. A 0 is not the same as NA, since R treats 0 as a numeric data class. x &lt;- rep(NA, 10) x[1] &lt;- 0 # test if zero is NA is.na(x) ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE We can also make a series of numbers using : or the seq() function. my_series &lt;- 1:10 # just integers my_series ## [1] 1 2 3 4 5 6 7 8 9 10 # make series of numbers from 1 to 10 by increments of 0.1 my_seq &lt;- seq(from = 1, to = 10, by = 0.1) my_seq ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 ## [16] 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 ## [31] 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 ## [46] 5.5 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 ## [61] 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 8.0 8.1 8.2 8.3 8.4 ## [76] 8.5 8.6 8.7 8.8 8.9 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 ## [91] 10.0 5.6.3 Lists A list in R is essentially an object with data that can be in different data types/modes. # list with numeric, character, and logical classes my_list &lt;- list(1, &quot;banana&quot;, TRUE) your_list &lt;- list(2, &quot;apple&quot;, FALSE) my_list ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;banana&quot; ## ## [[3]] ## [1] TRUE # we can also append to a list with c() like we did to a vector my_list &lt;- c(my_list, c(&quot;Lion171&quot;, &quot;S222&quot;)) The $ is called the operator, and it is used for indexing named elements in a list. It allows you to access part of a data object for extracting or subsetting data. my_lions &lt;- list(&quot;L211&quot;, c(&quot;L194&quot;, &quot;S789&quot;), &quot;L180&quot;) names(my_lions) # are names automatically assigned? Nope, so let&#39;s assign names with the names() function. ## NULL names(my_lions) &lt;- c(&quot;Lion211&quot;, &quot;LionsAndSheep&quot;, &quot;Lion180&quot;) my_lions$LionsAndSheep ## [1] &quot;L194&quot; &quot;S789&quot; If you wanted to index a specific element in the list, you could also use brackets # index second list [[2]] and second element [2] of the second list my_lions[[2]][2] ## [1] &quot;S789&quot; 5.6.4 Matrix A matrix in R is a two-dimensional data structure that stores elements of the same type (usually numbers). You can think of it like a spreadsheet or a table with rows and columns, but every value must be the same type (e.g., all numeric or all character). Matrices are useful when you want to perform mathematical operations on tables of numbers, like multiplying rows and columns, or applying functions across rows or columns. MyMatrix &lt;- matrix(1:6, nrow = 2, ncol = 3) MyMatrix ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 5.6.5 Data Frames A data frame in R is a like a list or generalized matrix but with the constraints that: all list elements are vectors (i.e. they have 1 mode), all vectors have the same length all columns (the list elements) have names Essentially, imagine each column in the dataframe as a vector, and the dataframe is just a big list of all those vectors. Unlike actual lists however, in dataframes all of the columns/vectors MUST be the same length and have names. # Create vectors for each column sheep_id &lt;- c(&quot;S601&quot;, &quot;S602&quot;, &quot;S603&quot;) sex &lt;- c(&quot;F&quot;, &quot;M&quot;, &quot;F&quot;) age &lt;- c(4, 6, 3) capt_date &lt;- as.Date(c(&quot;2024-03-15&quot;, &quot;2024-03-16&quot;, &quot;2024-03-18&quot;)) capt_loc &lt;- c(&quot;Acrodectes Peak&quot;, &quot;Sawmill Canyon&quot;, &quot;Goodale Canyon&quot;) # Combine into a data frame capt_dat &lt;- data.frame( ID = sheep_id, Sex = sex, Age = age, CaptureDate = capt_date, CaptureLoc = capt_loc, stringsAsFactors = FALSE # Ensures character columns are maintained as characters (not factors) ) # View the data frame print(capt_dat) ## ID Sex Age CaptureDate CaptureLoc ## 1 S601 F 4 2024-03-15 Acrodectes Peak ## 2 S602 M 6 2024-03-16 Sawmill Canyon ## 3 S603 F 3 2024-03-18 Goodale Canyon 5.7 Functions We’ve used several functions in the previous code. So what is a function? A function is a defined script that is used to accomplish a particular task. Functions use an input to give a desired output. Every function has arguments that determine what kind of inputs are needed to make the function run. The inputs in a function are called arguments. Arguments: information that goes inside the parenthesis to tell the function what to do. For example, when we used the seq function above, the arguments are from = 1, to = 10, and by = 0.1. Pass: We pass a value to a function argument. Above, we pass the value 1 to the argument from, and the value 10 to the argument to and the value 0.1 to the argument by Return: This is the terminology to say that the function gives us an output. So with the seq(from = 1, to = 10, by = 0.1), the function returns a sequence of numbers The order that we put the arguments into the function matters. It can be helpful to define the arguments in the function. You can use the help function to ensure that your arguments are correct. ?seq 5.8 Indexing So now that we’ve created dummy vectors to play with, how do we get at its contents? To extract elements of a vector we can give their corresponding index (square brackets [] are used for indexing). R uses 1-based indexing, so the first element of a vector, list, or dataframe is accessed using the index 1 (Python and C use 0-based indexing). my_seq[1] # extract first element out of the my_seq vector ## [1] 1 my_series[4] # extract 4th element out of the my_series vector ## [1] 4 my_seq[c(2:4)] # extract elements 2 to 4 from the my_seq vector ## [1] 1.1 1.2 1.3 We can also extract elements by using their name instead of extracting by index. Names are another attribute that you can give to data. They are often useful so that you don’t have to type out a lot of numbers. x &lt;- c(5.4, 6.2, 7.1, 4.8, 7.5) # create vector names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # assign names to vector # we can also name a vector &#39;on the fly&#39; x &lt;- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) x[c(&quot;a&quot;, &quot;c&quot;)] ## a c ## 5.4 7.1 Since comparison operators (e.g. &gt;, &lt;, ==) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one. x[x &gt; 7] # this statement first evaluates x&gt;7, generating a logical vector ## c e ## 7.1 7.5 # c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of x # corresponding to the TRUE values. If we use a negative number as the index of a vector, R will return every element except for the one specified: x[-2] ## a c d e ## 5.4 7.1 4.8 7.5 # we can skip multiple elements x[c(-1, -5)] ## b c d ## 6.2 7.1 4.8 # or x[-c(1,5)] ## b c d ## 6.2 7.1 4.8 # a common mistake would be to ask R x[-1:3] # but there isn&#39;t a negative first row # But remember the order of operations. # : is really a function. It takes its first argument as -1, # and its second as 3, so generates the sequence of # numbers: c(-1, 0, 1, 2, 3). x[-(1:3)] ## d e ## 4.8 7.5 # To remove elements from a vector, we need to assign the result # back into the variable: x &lt;- x[-4] x ## a b c e ## 5.4 6.2 7.1 7.5 "],["tidyverse.html", "Chapter 6 Tidyverse 6.1 Why Tidyverse? 6.2 Main dplyr functions: 6.3 GGPLOT2", " Chapter 6 Tidyverse 6.1 Why Tidyverse? The tidyverse is a collection of R packages designed to simplify and streamline data science tasks. It promotes the concept of “tidy data,” where each column is a variable and each row is an observation, which simplifies analysis and visualization. Core tidyverse packages include ggplot2 for plotting, dplyr for data manipulation, and tidyr for reshaping data. One of the key strengths of the tidyverse is its readable syntax, especially with the use of the pipe operator (%&gt;%), which allows users to chain together multiple steps in a clear, logical order. Learning the tidyverse equips beginners with practical tools and workflows that are essential for modern data analysis in R. One of the most commonly used packages within the tidyverse is dplyr (data plier), which provides a set of powerful and intuitive functions for manipulating data frames. With dplyr, you can easily filter rows, select columns, create new variables, group data, and summarize it—all using clear, readable code. Key Features: Consistent syntax across packages, making code easier to write and read. Tidy data structure, where each variable is a column and each observation is a row. Readable workflows using the pipe operator (%&gt;%) to chain commands clearly. Integrated tools for the entire data science process—importing, cleaning, transforming, visualizing, and modeling data. User-friendly functions with intuitive names and logical default argument values. Open-source and widely supported, with ample online learning resources Provides tools for data manipulation, exploration, and visualization. Uses piping (%&gt;%) to create readable, fluent workflows (through the magrittr package) 6.2 Main dplyr functions: dplyr, a main package of the tidyverse, consists of five main functions: filter() select() mutate() summarize() arrange() group_by() EXERCISES (Use filter to…) (Use mutate to…) (Select x columns) (group by sheep and summarize data) 6.3 GGPLOT2 ggplot2 is a powerful and flexible R package used for data visualization. It is part of the tidyverse and is built on the Grammar of Graphics—a layered approach to building plots that allows you to combine data, visual elements, and aesthetics step by step. Key Features Layered plotting system: Build plots by adding layers (e.g., points, lines, bars). Aesthetic mapping: Easily map variables to visual properties like color, size, and shape. Customizable: Control themes, labels, scales, and more for polished, publication-ready graphics. Works seamlessly with tidy data and other tidyverse tools. Example of using ggplot to plot some bighorn thing EXERCISE 2 1. "],["debugging-code.html", "Chapter 7 Debugging Code 7.1 Check Your Parenthesis! 7.2 Coercian Problems 7.3 Do you need to label your arguments in your function? 7.4 Use the help function in RStudio! 7.5 …", " Chapter 7 Debugging Code Artwork by Allison Horst Even when you know R well, you will inevitably find yourself in a situation where you don’t understand a package, have an error, don’t know the right function to use, or need ideas of how to write the correct code. 7.1 Check Your Parenthesis! 7.2 Coercian Problems 7.3 Do you need to label your arguments in your function? 7.4 Use the help function in RStudio! 7.5 … USE GOOGLE! Using a google search will most often give you results that can answer your questions. Most packages have a documentation page that you can google if you don’t understand how it works too. For example, I could google, “how do I use the seq function in R to return a sequence of numbers by 0.5?” It’s important to note that you are using the programming language R, and the objective that you want to take. Never be afraid to google if you run into trouble! The website stackoverflow is your friend. ChatGPT can be very useful, but it can sometimes be correct. Overuse of AI can also prevent you from developing your coding skills. "],["ForLoops.html", "Chapter 8 For Loops", " Chapter 8 For Loops WIP Easy for loop is to get mean weight by herd, or something like that "],["data-organization.html", "Chapter 9 Data Organization", " Chapter 9 Data Organization Let’s download some data and look at a dataframe mort &lt;- read.csv(&quot;./docs/data/BighornMortTable.csv&quot;) If we look at the data, we can see that each column is a specific data type, and we can index it with the operator. mort$Animal_ID[1] ## [1] &quot;M267&quot; We can use the functions head() and tail() to look at the first or last 6 rows of the data frame. head(mort, 3) ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 ## 2 21-Jan-25 20250121 25-Jun-23 20230625 NA ## 3 05-Jan-25 20250105 02-Dec-24 20241202 02-Dec-24 20241202 ## AgeCarcass BestDead AnimalYear Recorder Herd Animal_ID Sex ## 1 9 NA NA C_Massing Mt. Williamson M267 Male ## 2 583 NA NA M_Christopher Mt. Baxter M266 Male ## 3 33 20241202 2024 L_Greene Mt. Gibbs M265 Unknown ## Age AgeEstMethod GPS_CollarSerialNo_Date_FK CollarSN VHF_freq ## 1 6 Horn Rings ## 2 11 Horn Rings ## 3 0 Size of Remains ## Location InvestReason ## 1 On Shepherd Pass trail, 1 mi up from TH, ~6800ft elevation Opportunistic ## 2 Sand Mtn Opportunistic ## 3 Gibbs, S side Lion Cluster ## UTM_E UTM_N ElevDEM CarcassCon Cause_Mort CausMortAcc ## 1 384668 4067085 NA Consumed Lion Certain ## 2 384854 4085215 NA Consumed Unknown ## 3 306232 4193944 NA Consumed Lion Certain ## ConditionNotes ## 1 skeleton intact, ribs clipped, eaten, most meat eaten but not all, legs with hair still intact ## 2 old carcass, bleached bones, still close together, complete skull attached to spine, couple loose ribs, jaw, pelvis ## 3 rumen and lower leg, snow may have covered some remains ## Evidence ## 1 rumen intact, ribs clipped, hair plucked. ## 2 could be lion, clipped ribs, broken pelvis, leg bones chewed, all bones clost together, but it is all too old to be sure ## 3 lion cluster, broken long bones, rumen intact ## Comments ## 1 Lion could have scavenged dead sheep. Sheep on trail, not below cliff. Collected scat in possible latrine, it was liquid (had dried), hard to know if it was lion scat. Lion hairs found in bed near carcass. Snow fell 5 days before and did not find clear tracks around carcass other than human and canine. ## 2 estimated date of death based on condition of bones, very unknown but skeleton still there and mostly intact ## 3 metarsus measured ~21cm which could be very small adult or more likely lamb ## CauseMortRevised RevisionReason PhotoTaken Houndsmen RumenIntact TracksFound ## 1 Y Y N ## 2 Y N N ## 3 Y Y ## ScatFound DragMarks Latrine Femur Tooth Mandible Skull LionID ## 1 N N N N N ## 2 N N N N N N N ## 3 267 ## KillLocUsingGPSData LionClusterID ## 1 N ## 2 N ## 3 Y 267_20241202 Similarly, [[ will act to extract a single column: mort[[&quot;AnimalYear&quot;]][500] ## [1] 2016 We could also use brackets to index specific elements of the dataframe. Remember that when you index a dataframe using square brackets, the order is rows, columns. # [rows, columns] mort[1,2] # grab element at first row and second column ## [1] 20250131 mort[1,1:6] # grab row 1 in columns 1-6 ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 mort[1:6,5] # grab row 1-6 in column 5 ## [1] &quot;30-Jan-25&quot; &quot;&quot; &quot;02-Dec-24&quot; &quot;&quot; &quot;08-May-24&quot; &quot;08-Mar-24&quot; mort[1:6,1:6] # grab row 1-6 in columns 1-6 ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 ## 2 21-Jan-25 20250121 25-Jun-23 20230625 NA ## 3 05-Jan-25 20250105 02-Dec-24 20241202 02-Dec-24 20241202 ## 4 08-Sep-24 20240908 26-Feb-17 20170226 NA ## 5 09-Jul-24 20240709 11-Mar-24 20240311 08-May-24 20240508 ## 6 17-Jun-24 20240617 08-Mar-24 20240308 08-Mar-24 20240308 head(mort[,1:3], 5) # grab all rows from columns 1-3, show me the first 5 rows ## NecropDateDt NecropDate DeadDateDt ## 1 31-Jan-25 20250131 22-Jan-25 ## 2 21-Jan-25 20250121 25-Jun-23 ## 3 05-Jan-25 20250105 02-Dec-24 ## 4 08-Sep-24 20240908 26-Feb-17 ## 5 09-Jul-24 20240709 11-Mar-24 You can coerce lists to data.frames, assuming they follow the data frame rules. test.list &lt;- list(1, &quot;banana&quot;, TRUE) class(test.list) ## [1] &quot;list&quot; my_seq &lt;- as.data.frame(test.list) class(my_seq) ## [1] &quot;data.frame&quot; R is a natively vectorized language. Meaning it automatically performs vector operations. All of this starts to make sense if you’re having trouble subsetting with $ or even [] or [[]]. "],["exploring-data-frames.html", "Chapter 10 Exploring Data Frames 10.1 Data Frame Manipulation", " Chapter 10 Exploring Data Frames Let’s check out the data! Data exploration is one of the most important parts of working in R and it’s the first thing you should always do when looking at new data! # str() shows us the structure of the data, including the data mode, # the dimensions of # the dataframe including the data mode, the dimensions of # the dataframe, and a few observations str(mort) ## &#39;data.frame&#39;: 1061 obs. of 45 variables: ## $ NecropDateDt : chr &quot;31-Jan-25&quot; &quot;21-Jan-25&quot; &quot;05-Jan-25&quot; &quot;08-Sep-24&quot; ... ## $ NecropDate : int 20250131 20250121 20250105 20240908 20240709 20240617 20240604 20240530 20240528 20240520 ... ## $ DeadDateDt : chr &quot;22-Jan-25&quot; &quot;25-Jun-23&quot; &quot;02-Dec-24&quot; &quot;26-Feb-17&quot; ... ## $ DeadDate : int 20250122 20230625 20241202 20170226 20240311 20240308 20230925 20240127 20240101 20240430 ... ## $ Date1stHeardDt : chr &quot;30-Jan-25&quot; &quot;&quot; &quot;02-Dec-24&quot; &quot;&quot; ... ## $ Date1stHeard : int 20250130 NA 20241202 NA 20240508 20240308 20230925 20240127 20240101 20240430 ... ## $ AgeCarcass : int 9 583 33 NA 120 NA 254 123 120 21 ... ## $ BestDead : int NA NA 20241202 20170226 20240311 20240308 20230925 20240127 20240101 20240430 ... ## $ AnimalYear : int NA NA 2024 2016 2023 2023 2023 2023 2023 2023 ... ## $ Recorder : chr &quot;C_Massing&quot; &quot;M_Christopher&quot; &quot;L_Greene&quot; &quot;L_Greene&quot; ... ## $ Herd : chr &quot;Mt. Williamson&quot; &quot;Mt. Baxter&quot; &quot;Mt. Gibbs&quot; &quot;Mt. Langley&quot; ... ## $ Animal_ID : chr &quot;M267&quot; &quot;M266&quot; &quot;M265&quot; &quot;S217&quot; ... ## $ Sex : chr &quot;Male&quot; &quot;Male&quot; &quot;Unknown&quot; &quot;Male&quot; ... ## $ Age : chr &quot;6&quot; &quot;11&quot; &quot;0&quot; &quot;5&quot; ... ## $ AgeEstMethod : chr &quot;Horn Rings&quot; &quot;Horn Rings&quot; &quot;Size of Remains&quot; &quot;Horn Rings&quot; ... ## $ GPS_CollarSerialNo_Date_FK: chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ CollarSN : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ VHF_freq : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ Location : chr &quot;On Shepherd Pass trail, 1 mi up from TH, ~6800ft elevation&quot; &quot;Sand Mtn&quot; &quot;Gibbs, S side&quot; &quot;Hitchcock Ridge, near rainbow camp&quot; ... ## $ InvestReason : chr &quot;Opportunistic&quot; &quot;Opportunistic&quot; &quot;Lion Cluster&quot; &quot;opportunistic&quot; ... ## $ UTM_E : int 384668 384854 306232 378981 299699 352085 399881 352786 349902 381814 ... ## $ UTM_N : int 4067085 4085215 4193944 4046150 4216718 4142608 4012253 4149065 4144062 4079364 ... ## $ ElevDEM : int NA NA NA NA NA NA NA NA NA NA ... ## $ CarcassCon : chr &quot;Consumed&quot; &quot;Consumed&quot; &quot;Consumed&quot; &quot;Scavenged&quot; ... ## $ Cause_Mort : chr &quot;Lion&quot; &quot;Unknown&quot; &quot;Lion&quot; &quot;Unknown not Predation&quot; ... ## $ CausMortAcc : chr &quot;Certain&quot; &quot;&quot; &quot;Certain&quot; &quot;Certain&quot; ... ## $ ConditionNotes : chr &quot;skeleton intact, ribs clipped, eaten, most meat eaten but not all, legs with hair still intact&quot; &quot;old carcass, bleached bones, still close together, complete skull attached to spine, couple loose ribs, jaw, pelvis&quot; &quot;rumen and lower leg, snow may have covered some remains&quot; &quot;bone fragments and skull. Not in avalanche path, not cached&quot; ... ## $ Evidence : chr &quot;rumen intact, ribs clipped, hair plucked.&quot; &quot;could be lion, clipped ribs, broken pelvis, leg bones chewed, all bones clost together, but it is all too old to be sure&quot; &quot;lion cluster, broken long bones, rumen intact&quot; &quot;this ribs still attached to backbone, some gnawed off but not clipped.&quot; ... ## $ Comments : chr &quot;Lion could have scavenged dead sheep. Sheep on trail, not below cliff. Collected scat in possible latrine, it w&quot;| __truncated__ &quot;estimated date of death based on condition of bones, very unknown but skeleton still there and mostly intact&quot; &quot;metarsus measured ~21cm which could be very small adult or more likely lamb&quot; &quot;Originally censored but found opportunistically with collar and eartag. Bones starting to get crumbly, may have&quot;| __truncated__ ... ## $ CauseMortRevised : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ RevisionReason : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ PhotoTaken : chr &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; &quot;&quot; ... ## $ Houndsmen : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ RumenIntact : chr &quot;Y&quot; &quot;N&quot; &quot;Y&quot; &quot;&quot; ... ## $ TracksFound : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;&quot; ... ## $ ScatFound : chr &quot;&quot; &quot;N&quot; &quot;&quot; &quot;&quot; ... ## $ DragMarks : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;&quot; ... ## $ Latrine : chr &quot;&quot; &quot;N&quot; &quot;&quot; &quot;&quot; ... ## $ Femur : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;n&quot; ... ## $ Tooth : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;n&quot; ... ## $ Mandible : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;n&quot; ... ## $ Skull : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;n&quot; ... ## $ LionID : chr &quot;&quot; &quot;&quot; &quot;267&quot; &quot;&quot; ... ## $ KillLocUsingGPSData : chr &quot;N&quot; &quot;N&quot; &quot;Y&quot; &quot;n&quot; ... ## $ LionClusterID : chr &quot;&quot; &quot;&quot; &quot;267_20241202&quot; &quot;&quot; ... length(mort) # gives the number of columns ## [1] 45 nrow(mort) # to get the number of rows ## [1] 1061 ncol(mort) # number of columns ## [1] 45 dim(mort) # or both at once, dim() ## [1] 1061 45 colnames(mort) # names of the columns ## [1] &quot;NecropDateDt&quot; &quot;NecropDate&quot; ## [3] &quot;DeadDateDt&quot; &quot;DeadDate&quot; ## [5] &quot;Date1stHeardDt&quot; &quot;Date1stHeard&quot; ## [7] &quot;AgeCarcass&quot; &quot;BestDead&quot; ## [9] &quot;AnimalYear&quot; &quot;Recorder&quot; ## [11] &quot;Herd&quot; &quot;Animal_ID&quot; ## [13] &quot;Sex&quot; &quot;Age&quot; ## [15] &quot;AgeEstMethod&quot; &quot;GPS_CollarSerialNo_Date_FK&quot; ## [17] &quot;CollarSN&quot; &quot;VHF_freq&quot; ## [19] &quot;Location&quot; &quot;InvestReason&quot; ## [21] &quot;UTM_E&quot; &quot;UTM_N&quot; ## [23] &quot;ElevDEM&quot; &quot;CarcassCon&quot; ## [25] &quot;Cause_Mort&quot; &quot;CausMortAcc&quot; ## [27] &quot;ConditionNotes&quot; &quot;Evidence&quot; ## [29] &quot;Comments&quot; &quot;CauseMortRevised&quot; ## [31] &quot;RevisionReason&quot; &quot;PhotoTaken&quot; ## [33] &quot;Houndsmen&quot; &quot;RumenIntact&quot; ## [35] &quot;TracksFound&quot; &quot;ScatFound&quot; ## [37] &quot;DragMarks&quot; &quot;Latrine&quot; ## [39] &quot;Femur&quot; &quot;Tooth&quot; ## [41] &quot;Mandible&quot; &quot;Skull&quot; ## [43] &quot;LionID&quot; &quot;KillLocUsingGPSData&quot; ## [45] &quot;LionClusterID&quot; It’s a good time to ask ourselves if the structure R is reporting matches our intuition: Does the data type for each column make sense? If not, we need to sort out those issues now so we Don’t run into issues down the road. Once we’re happy with our data types, we can really start digging into our data! We can also examine individual columns: class(mort$AnimalYear) ## [1] &quot;integer&quot; class(mort$Animal_ID) ## [1] &quot;character&quot; str(mort$Cause_Mort) ## chr [1:1061] &quot;Lion&quot; &quot;Unknown&quot; &quot;Lion&quot; &quot;Unknown not Predation&quot; &quot;Lion&quot; ... 10.1 Data Frame Manipulation Let’s create a new column to hold information on whether bighorn age is &lt; 5: below_five &lt;- mort$Age &lt; 5 head(below_five) ## [1] FALSE TRUE TRUE FALSE TRUE FALSE We’ve simply created a vector with TRUE/FALSE values; but we can add this to our dataframe using: mort &lt;- cbind(mort, below_five) head(cbind(mort, below_five), 3) ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 ## 2 21-Jan-25 20250121 25-Jun-23 20230625 NA ## 3 05-Jan-25 20250105 02-Dec-24 20241202 02-Dec-24 20241202 ## AgeCarcass BestDead AnimalYear Recorder Herd Animal_ID Sex ## 1 9 NA NA C_Massing Mt. Williamson M267 Male ## 2 583 NA NA M_Christopher Mt. Baxter M266 Male ## 3 33 20241202 2024 L_Greene Mt. Gibbs M265 Unknown ## Age AgeEstMethod GPS_CollarSerialNo_Date_FK CollarSN VHF_freq ## 1 6 Horn Rings ## 2 11 Horn Rings ## 3 0 Size of Remains ## Location InvestReason ## 1 On Shepherd Pass trail, 1 mi up from TH, ~6800ft elevation Opportunistic ## 2 Sand Mtn Opportunistic ## 3 Gibbs, S side Lion Cluster ## UTM_E UTM_N ElevDEM CarcassCon Cause_Mort CausMortAcc ## 1 384668 4067085 NA Consumed Lion Certain ## 2 384854 4085215 NA Consumed Unknown ## 3 306232 4193944 NA Consumed Lion Certain ## ConditionNotes ## 1 skeleton intact, ribs clipped, eaten, most meat eaten but not all, legs with hair still intact ## 2 old carcass, bleached bones, still close together, complete skull attached to spine, couple loose ribs, jaw, pelvis ## 3 rumen and lower leg, snow may have covered some remains ## Evidence ## 1 rumen intact, ribs clipped, hair plucked. ## 2 could be lion, clipped ribs, broken pelvis, leg bones chewed, all bones clost together, but it is all too old to be sure ## 3 lion cluster, broken long bones, rumen intact ## Comments ## 1 Lion could have scavenged dead sheep. Sheep on trail, not below cliff. Collected scat in possible latrine, it was liquid (had dried), hard to know if it was lion scat. Lion hairs found in bed near carcass. Snow fell 5 days before and did not find clear tracks around carcass other than human and canine. ## 2 estimated date of death based on condition of bones, very unknown but skeleton still there and mostly intact ## 3 metarsus measured ~21cm which could be very small adult or more likely lamb ## CauseMortRevised RevisionReason PhotoTaken Houndsmen RumenIntact TracksFound ## 1 Y Y N ## 2 Y N N ## 3 Y Y ## ScatFound DragMarks Latrine Femur Tooth Mandible Skull LionID ## 1 N N N N N ## 2 N N N N N N N ## 3 267 ## KillLocUsingGPSData LionClusterID below_five below_five ## 1 N FALSE FALSE ## 2 N TRUE TRUE ## 3 Y 267_20241202 TRUE TRUE head(mort, 3) ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 ## 2 21-Jan-25 20250121 25-Jun-23 20230625 NA ## 3 05-Jan-25 20250105 02-Dec-24 20241202 02-Dec-24 20241202 ## AgeCarcass BestDead AnimalYear Recorder Herd Animal_ID Sex ## 1 9 NA NA C_Massing Mt. Williamson M267 Male ## 2 583 NA NA M_Christopher Mt. Baxter M266 Male ## 3 33 20241202 2024 L_Greene Mt. Gibbs M265 Unknown ## Age AgeEstMethod GPS_CollarSerialNo_Date_FK CollarSN VHF_freq ## 1 6 Horn Rings ## 2 11 Horn Rings ## 3 0 Size of Remains ## Location InvestReason ## 1 On Shepherd Pass trail, 1 mi up from TH, ~6800ft elevation Opportunistic ## 2 Sand Mtn Opportunistic ## 3 Gibbs, S side Lion Cluster ## UTM_E UTM_N ElevDEM CarcassCon Cause_Mort CausMortAcc ## 1 384668 4067085 NA Consumed Lion Certain ## 2 384854 4085215 NA Consumed Unknown ## 3 306232 4193944 NA Consumed Lion Certain ## ConditionNotes ## 1 skeleton intact, ribs clipped, eaten, most meat eaten but not all, legs with hair still intact ## 2 old carcass, bleached bones, still close together, complete skull attached to spine, couple loose ribs, jaw, pelvis ## 3 rumen and lower leg, snow may have covered some remains ## Evidence ## 1 rumen intact, ribs clipped, hair plucked. ## 2 could be lion, clipped ribs, broken pelvis, leg bones chewed, all bones clost together, but it is all too old to be sure ## 3 lion cluster, broken long bones, rumen intact ## Comments ## 1 Lion could have scavenged dead sheep. Sheep on trail, not below cliff. Collected scat in possible latrine, it was liquid (had dried), hard to know if it was lion scat. Lion hairs found in bed near carcass. Snow fell 5 days before and did not find clear tracks around carcass other than human and canine. ## 2 estimated date of death based on condition of bones, very unknown but skeleton still there and mostly intact ## 3 metarsus measured ~21cm which could be very small adult or more likely lamb ## CauseMortRevised RevisionReason PhotoTaken Houndsmen RumenIntact TracksFound ## 1 Y Y N ## 2 Y N N ## 3 Y Y ## ScatFound DragMarks Latrine Femur Tooth Mandible Skull LionID ## 1 N N N N N ## 2 N N N N N N N ## 3 267 ## KillLocUsingGPSData LionClusterID below_five ## 1 N FALSE ## 2 N TRUE ## 3 Y 267_20241202 TRUE Note that if we try to add a vector of below_average with a different number of entries then the number of rows in our data frame, it would fail: below_five &lt;- c(TRUE, TRUE, TRUE, TRUE, TRUE) head(cbind(mort, below_five)) The sequence TRUE,TRUE,FALSE is repeated over all the gapminder rows. Let’s overwite the content of gapminder with our new data frame. below_five &lt;- as.logical(mort$Age&lt;5) gapminder &lt;- cbind(mort, below_five) How about adding rows? # first let&#39;s make a mortality dataframe of 3 columns mort_short &lt;- mort[,c(&quot;Animal_ID&quot;, &quot;Age&quot;, &quot;Cause_Mort&quot;)] new_row &lt;- list(&#39;S781&#39;, 3, &quot;Lion&quot;) # note that we have to make the row a list, since each column has a different data type mort_new &lt;- rbind(mort_short, new_row) tail(mort_new) # lets you look at the last 6 lines of data "],["making-readable-r-code.html", "Chapter 11 Making Readable R Code 11.1 Outlining R Scripts 11.2 Making Readable R Code", " Chapter 11 Making Readable R Code 11.1 Outlining R Scripts R scripts can get long, and it can get a bit unwieldy to navigate between different sections of your script. One neat way to outline your script is by using comment headers as bookmarks. This can be accomplished by either putting ---- or #### after a commented line. # 1. Section ---- ## a. Subsection #### ### i. Sub-subsection ---- 11.2 Making Readable R Code Start each script with a brief description of what it does, who wrote it, and the last date it was edited. Then load all required packages, define functions, and set any variables used consistently throughout your script. Example: If you are going to be exporting many plots during the course of your script, you could set a variable to the output folder. Setting variables allows you to not have repeat code. output_plots &lt;- \"output/plots/\" You can source functions from a separate script using source(). Remember what working directory you are in when sourcing a script. Use comments to mark off sections of code. Outline your script Name and style code consistently. Spacing can make code more readable, but it’s really up to personal preference. Break code into small, discrete pieces. Think about the best way to organize your directory given your objectives. I often have sub folders for data, output, and docs. Start with a clean environment instead of saving the work space. Consider using version control (i.e. Github). "],["stats.html", "Chapter 12 Stats", " Chapter 12 Stats WIP "],["wip.html", "Chapter 13 WIP", " Chapter 13 WIP "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
