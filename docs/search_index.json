[["using-r.html", "Chapter 5 Using R 5.1 Installing Packages 5.2 Use R as a calculator 5.3 Use R to compare things 5.4 Use R to assign objects 5.5 Data Types (Modes) 5.6 Data Structure Classes 5.7 Functions 5.8 Indexing", " Chapter 5 Using R 5.1 Installing Packages Sometimes you will want to use tools that are not built into the baseR code. You can download these tools from R repositories as packages. A package is a collection of functions, data, and documentation bundled together for a specific function. An R package can help with data visualization, statistical modeling, or data cleaning. You can install an R package through the RStudio interface, or through entering code into the console install.packages(&quot;amt&quot;) # install a new package library(amt) # call a package you previously downloaded EXERCISE 4: LOAD TIDYVERSE PACKAGE USING RSTUDIO Select Packages Select Install Type tidyverse Select Install Bonus: Install tidyverse in the code editor using the example code above. We will go over what tidyverse is later on in this course If two different packages contain functions with the same name, R will mask one with the other based on the order they are loaded. To avoid confusion, you can explicitly tell R which package to use by using the package::function() format. For example, the filter() function exists in both stats and dplyr packages. If you specifically want the version from dplyr, you can write dplyr::filter() in your code. We will talk more about this later on. 5.2 Use R as a calculator Remember, order of operations matters. The order is the same as you learned back in school. From highest to lowest precedence: Operator Symbol(s) Description Parentheses ( ) Controls the order of operations Exponents ^, ** Raises a number to a power Divide / Division Multiply * Multiplication Add + Addition Subtract - Subtraction 1 + 100 ## [1] 101 3 + 5 * 2 # performs multiplication before addition ## [1] 13 (3 + 5) * 2 # performs addition in () before multiplication ## [1] 16 2/10000 ## [1] 2e-04 2^3 # text after a code line is called a &quot;comment&quot; ## [1] 8 5.3 Use R to compare things To compare things in R, we use logical operators. Below is a brief list. Summary of logical operators == is equal to &gt; greater than &lt; less than &gt;= greater than or equal &lt;= less than or equal ! not | or %in% is contained 1 == 9 # equality (note two equals signs, read as &quot;is equal to&quot;) ## [1] FALSE 1 != 1 # inequality (read as &quot;is not equal to&quot;) ## [1] FALSE 1 &lt; 2 # less than ## [1] TRUE 1 &lt;= 1 # less than or equal to ## [1] TRUE Notice how R evaluates each of these lines of code as TRUE or FALSE. We are essentially asking R if the above comparison is TRUE or FALSE. EXCERCIZE 1 In your code editor, write the following lines of code. Then execute the lines of code so you see the output in your console. 67 * 9 7 + 9 + 10 4399 - 871 * (9 + 1) Bonus: What is wrong with the following code? Type 87(9 + 1) into your console Execute that specific line of code by placing the cursor on that line and selecting Run. What error do you see? What do you think is happening? How might you fix this? 5.4 Use R to assign objects Objects are a bit of an abstract concept. All you really need to know for now is that objects are things that we make in R that can take on a variety of structures with different data types, and when we assign them a name, they get saved in our global environment. They are data structures with associated data attributes. Object assignment allows us to assign a variable name to the object for later use. This helps prevent writing redundant code. We assign an object to a variable using the assignment arrow &lt;- or the = so that R knows that x is an object that we can use. So when we run, x &lt;- 6, it reads “make x contain 6.” It’s recommended to use the &lt;- since the = can get mixed up with assigning values to function arguments (more on this later). Once we assign an object to a variable, it is stored in our global environment (upper right hand panel of R studio). x &lt;- 1/40 # here we are telling R to assign 1/40 to the variable x so that it recognizes x as an object in our global environment x ## [1] 0.025 x = 24 # variables can easily be re-assigned/over-written y &lt;- x * 2 rm(y) # you can also remove objects from the environment 5.4.1 Variable names Variable names can contain letters, numbers, underscores and periods. They CANNOT start with a number OR contain spaces (at all). Remember that R is case sensitive. A few different conventions for longer variable names: periods.between.words underscores_between_words camelCaseToSeparateWords Your choice of convention is up to you, JUST BE CONSISTENT. EXERCISE 2 Assign 1+56 to a variable called x1_a Assign sqrt(24) to a variable called x1_b Bonus: Chained assignments. What happens when you execute x3.c &lt;- y3.c &lt;- 9/10 into your console? Are x3.c and y3.c different or equal values? 5.5 Data Types (Modes) There are 6 main classes of common data modes (i.e. data types): numeric, character, logical, complex, and raw. Data modes refers to the basic type of data stored in an object. For example, numeric mode stores numbers (integers or decimals), and character mode stores text. We typically only use factor, numeric, character, and logical data modes. Mode Description Example factor Categorical data “Sheep”, “Lion”, “Deer” numeric Numbers (includes integers and decimals) 3.14, 42 character Text strings “Lion180” logical TRUE or FALSE values TRUE, FALSE To ask R what class a data mode or object is, we use the function class(). class(1.11) # numeric: any real number class(1L) # integer: any integer. The L suffix forces the number to be an integer class(TRUE) # logical: binary TRUE or FALSE # You can have data that look essentially the same, but have different classes. class(&#39;1&#39;) # character: words; &quot;&quot; denote words class(1) # numeric; any real number class(factor(&quot;1a&quot;)) # factor: denotes categorical variables, they can be words or numbers You can coerce to a desired data type, as long as they follow the rules using the functions as.&lt;desired data type&gt; Coercian Hierarchy from general to specific: Logical -&gt; Numeric -&gt; Factor -&gt; Character logical (least general, cannot turn turn character or numeric into a logical type without correctly specifying the value) numeric (can read integer and logical types as numbers) character (most general: anything can be turned into a character by adding “quotes”) # Convert from numeric to integer a &lt;- 45.6 class(a) ## [1] &quot;numeric&quot; # Convert from numeric to character a_character &lt;- as.character(a) class(a_character) ## [1] &quot;character&quot; # Create factored variable lion &lt;- factor(c(&quot;194&quot;), levels = c(&quot;194&quot;)) lion # print value into console ## [1] 194 ## Levels: 194 as.numeric(lion) # coerced to numeric ## [1] 1 as.character(lion) # coerced to character ## [1] &quot;194&quot; as.numeric(as.character(lion)) # coerced to character, then numeric ## [1] 194 A common mistake in R is using data of the wrong type. In the example below, an error occurs because R cannot convert a character value into a numeric one. It’s important to ensure that the data you’re working with is of the correct type. Also, remember that each column in a data frame should contain values of the same type. # convert from character to numeric b &lt;- &quot;banana&quot; b_numeric &lt;- as.numeric(b) ## Warning: NAs introduced by coercion EXERCISE 3 Assign \"S437\" to a variable called “sheep”. Make sure to include the \"\". What type of data class is sheep? Create an object with a value of 45. Coerce to a character class using as.character(). Execute S1 &lt;- as.numeric(as.character(1)) and S2 &lt;- as.logical(as.numeric(\"1\")). Do the values change? Why or why not? Think about this answer in the context of the coercian hierarchy. Bonus: What happens when you execute sheep &lt;- S437 without \"\"? Explain the error. 5.6 Data Structure Classes Remember when we talked about objects as data with attributes? Well, R offers several ways to store data, depending on what kind of structure you need. The most common types are vectors, data frames, and lists. Each of these can store different types of information and are useful in different contexts when working with data. Think of them as different types of containers for data that are designed to hold and organize data in specific ways. We will be discussing Scalar, Vector, Data Frames, Matrices, and Lists. Below is a summary of each of these data structures, and we will also go through each of these individually. Data Structure Description Can Contain Different Types? Dimensions Example Scalar A single value (a vector of length 1) No 1 (length = 1) x &lt;- 42 Vector A sequence of elements of the same type No 1 (length &gt; 1) c(1, 2, 3) Data Frame Table-like structure with columns of equal length Yes (by column) 2 (rows × cols) data.frame(a = 1:3, b = c(\"x\", \"y\", \"z\")) Matrix 2D array with all elements of the same type No 2 (rows × cols) matrix(1:6, nrow = 2) List A collection of elements that can be of different types Yes 1 (named or not) list(name = \"A\", age = 25, scores = c(1,2,3)) 5.6.1 Scalar A vector has one element with length 1. x &lt;- 3 5.6.2 Vector A vector in R is essentially a collection of items of the same basic data type. Each ‘thing’ in the vector is called an element. If you don’t choose the data type, it’ll default to logical; or, you can declare an empty vector of whatever type you like. You can also make vectors with explicit contents using the concatenate function c(). my.deer &lt;- c(&quot;GDL256&quot;, &quot;RVD1011&quot;, &quot;CDB567&quot;) my_vector &lt;- vector(length = 3) my_vector # this is a logical vector ## [1] FALSE FALSE FALSE num_vector &lt;- c(101, 222, 323, 435, 556) # numeric vector # what happens when we add elements of different data types to a vector? combine_vector &lt;- c(211, &quot;CDB678&quot;, TRUE) combine_vector ## [1] &quot;211&quot; &quot;CDB678&quot; &quot;TRUE&quot; class(combine_vector) ## [1] &quot;character&quot; R interprets the whole vector as character. It can’t make “banana” into a number but it can turn 2 and TRUE into text strings. This logic follows the coercian hierarchy. You can also assign NA values to a vector of defined length as well. R is able to handle missing values, and these missing values are given NA. When you read in an csv file with empty cells, R will assign these values as NA. A 0 is not the same as NA, since R treats 0 as a numeric data class. x &lt;- rep(NA, 10) x[1] &lt;- 0 # test if zero is NA is.na(x) ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE We can also make a series of numbers using : or the seq() function. my_series &lt;- 1:10 # just integers my_series ## [1] 1 2 3 4 5 6 7 8 9 10 # make series of numbers from 1 to 10 by increments of 0.1 my_seq &lt;- seq(from = 1, to = 10, by = 0.1) my_seq ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 ## [16] 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 ## [31] 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 ## [46] 5.5 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 ## [61] 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 8.0 8.1 8.2 8.3 8.4 ## [76] 8.5 8.6 8.7 8.8 8.9 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 ## [91] 10.0 5.6.3 Lists A list in R is essentially an object with data that can be in different data types/modes. # list with numeric, character, and logical classes my_list &lt;- list(1, &quot;banana&quot;, TRUE) your_list &lt;- list(2, &quot;apple&quot;, FALSE) my_list ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;banana&quot; ## ## [[3]] ## [1] TRUE # we can also append to a list with c() like we did to a vector my_list &lt;- c(my_list, c(&quot;Lion171&quot;, &quot;S222&quot;)) The $ is called the operator, and it is used for indexing named elements in a list. It allows you to access part of a data object for extracting or subsetting data. my_lions &lt;- list(&quot;L211&quot;, c(&quot;L194&quot;, &quot;S789&quot;), &quot;L180&quot;) names(my_lions) # are names automatically assigned? Nope, so let&#39;s assign names with the names() function. ## NULL names(my_lions) &lt;- c(&quot;Lion211&quot;, &quot;LionsAndSheep&quot;, &quot;Lion180&quot;) my_lions$LionsAndSheep ## [1] &quot;L194&quot; &quot;S789&quot; If you wanted to index a specific element in the list, you could also use brackets # index second list [[2]] and second element [2] of the second list my_lions[[2]][2] ## [1] &quot;S789&quot; 5.6.4 Matrix A matrix in R is a two-dimensional data structure that stores elements of the same type (usually numbers). You can think of it like a spreadsheet or a table with rows and columns, but every value must be the same type (e.g., all numeric or all character). Matrices are useful when you want to perform mathematical operations on tables of numbers, like multiplying rows and columns, or applying functions across rows or columns. MyMatrix &lt;- matrix(1:6, nrow = 2, ncol = 3) MyMatrix ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 5.6.5 Data Frames A data frame in R is a like a list or generalized matrix but with the constraints that: all list elements are vectors (i.e. they have 1 mode), all vectors have the same length all columns (the list elements) have names Essentially, imagine each column in the dataframe as a vector, and the dataframe is just a big list of all those vectors. Unlike actual lists however, in dataframes all of the columns/vectors MUST be the same length and have names. # Create vectors for each column sheep_id &lt;- c(&quot;S601&quot;, &quot;S602&quot;, &quot;S603&quot;) sex &lt;- c(&quot;F&quot;, &quot;M&quot;, &quot;F&quot;) age &lt;- c(4, 6, 3) capt_date &lt;- as.Date(c(&quot;2024-03-15&quot;, &quot;2024-03-16&quot;, &quot;2024-03-18&quot;)) capt_loc &lt;- c(&quot;Acrodectes Peak&quot;, &quot;Sawmill Canyon&quot;, &quot;Goodale Canyon&quot;) # Combine into a data frame capt_dat &lt;- data.frame( ID = sheep_id, Sex = sex, Age = age, CaptureDate = capt_date, CaptureLoc = capt_loc, stringsAsFactors = FALSE # Ensures character columns are maintained as characters (not factors) ) # View the data frame print(capt_dat) ## ID Sex Age CaptureDate CaptureLoc ## 1 S601 F 4 2024-03-15 Acrodectes Peak ## 2 S602 M 6 2024-03-16 Sawmill Canyon ## 3 S603 F 3 2024-03-18 Goodale Canyon 5.7 Functions We’ve used several functions in the previous code. So what is a function? A function is a defined script that is used to accomplish a particular task. Functions use an input to give a desired output. Every function has arguments that determine what kind of inputs are needed to make the function run. The inputs in a function are called arguments. Arguments: information that goes inside the parenthesis to tell the function what to do. For example, when we used the seq function above, the arguments are from = 1, to = 10, and by = 0.1. Pass: We pass a value to a function argument. Above, we pass the value 1 to the argument from, and the value 10 to the argument to and the value 0.1 to the argument by Return: This is the terminology to say that the function gives us an output. So with the seq(from = 1, to = 10, by = 0.1), the function returns a sequence of numbers The order that we put the arguments into the function matters. It can be helpful to define the arguments in the function. You can use the help function to ensure that your arguments are correct. ?seq 5.8 Indexing So now that we’ve created dummy vectors to play with, how do we get at its contents? To extract elements of a vector we can give their corresponding index (square brackets [] are used for indexing). R uses 1-based indexing, so the first element of a vector, list, or dataframe is accessed using the index 1 (Python and C use 0-based indexing). my_seq[1] # extract first element out of the my_seq vector ## [1] 1 my_series[4] # extract 4th element out of the my_series vector ## [1] 4 my_seq[c(2:4)] # extract elements 2 to 4 from the my_seq vector ## [1] 1.1 1.2 1.3 We can also extract elements by using their name instead of extracting by index. Names are another attribute that you can give to data. They are often useful so that you don’t have to type out a lot of numbers. x &lt;- c(5.4, 6.2, 7.1, 4.8, 7.5) # create vector names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # assign names to vector # we can also name a vector &#39;on the fly&#39; x &lt;- c(a = 5.4, b = 6.2, c = 7.1, d = 4.8, e = 7.5) x[c(&quot;a&quot;, &quot;c&quot;)] ## a c ## 5.4 7.1 Since comparison operators (e.g. &gt;, &lt;, ==) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one. x[x &gt; 7] # this statement first evaluates x&gt;7, generating a logical vector ## c e ## 7.1 7.5 # c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of x # corresponding to the TRUE values. If we use a negative number as the index of a vector, R will return every element except for the one specified: x[-2] ## a c d e ## 5.4 7.1 4.8 7.5 # we can skip multiple elements x[c(-1, -5)] ## b c d ## 6.2 7.1 4.8 # or x[-c(1,5)] ## b c d ## 6.2 7.1 4.8 # a common mistake would be to ask R x[-1:3] # but there isn&#39;t a negative first row # But remember the order of operations. # : is really a function. It takes its first argument as -1, # and its second as 3, so generates the sequence of # numbers: c(-1, 0, 1, 2, 3). x[-(1:3)] ## d e ## 4.8 7.5 # To remove elements from a vector, we need to assign the result # back into the variable: x &lt;- x[-4] x ## a b c e ## 5.4 6.2 7.1 7.5 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
