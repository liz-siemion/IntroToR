[["index.html", "CDFW Introduction to R Programming Chapter 1 Overview 1.1 Workshop Goals 1.2 Workshop Content", " CDFW Introduction to R Programming Liz Siemion &amp; Dave German 2025-05-15 Chapter 1 Overview 1.1 Workshop Goals This course introduces the foundational concepts of programming in R and using RStudio, with a focus on producing reproducible and well-documented workflows. Our goal is to equip you with the skills to continue learning R independently and to integrate R programming into your analyses and workflows. Artwork by Allison Horst 1.2 Workshop Content Intro to R and R-Studio Directory Structure File paths Tidy Data Packages Working with R objects Data types (factor, numeric, character, and logical) Data classes (scalar, vector, data frames, matrices, lists) Functions (arguments, function workflow) Indexing Importing and exporting data files (csv, xlsx, mdb, rds)] Data organization and manipulation (baseR and tidyverse) Vectorized Operations Basic plotting Control Structures For-loops Basic statistics &amp; statistical summaries Debugging Making readable R code I reference course materials from USU’s ecology center workshops, and Dr. Simona Picardi’s Reproducible data science website throughout this course. "],["intro.html", "Chapter 2 Intro to R and R-Studio 2.1 What is R? 2.2 Directory Structure 2.3 R Studio 2.4 RStudio Projects", " Chapter 2 Intro to R and R-Studio 2.1 What is R? R is both the name of the programming language and the software used for data storage and manipulation. RStudio is the Integrated Development Environment (IDE) for the R programming language that makes writing, running, and organizing R code more efficient. RStudio provides a centralized interface where you can manage your code, working directory, data, output, and environment all in one place. On my MacBook, I keep R and RStudio in the Applications folder, and on Windows, I store them on the C drive. You will need to download R before downloading RStudio. 2.2 Directory Structure Before creating an RStudio Project, it’s important to think about how your project is structured, as this will shape your directory (i.e. folder) organization. I typically create a separate folder for each analysis, and within each, I include subfolders for data, output, and scripts. Other folders might include figures, results, and documents. You may want to consider housing two projects in the same directory if they utilize the same data. All files need to be readable by the computer and should not contain white spaces, punctuation, or special characters. I generally follow the same naming conventions for my files (e.g., camelCase, snake_case, kebab-case, PascalCase). After setting up your directory structure, the next step is to create an RStudio Project in R Studio. EXERCISE 1: CREATING A WORKING DIRECTORY Create a new working directory named IntroR. You can put this folder in whichever location makes sense for you on your computer. Create subfolders named data, output, and scripts 2.3 R Studio First let’s go over the basics of RStudio. When you first open RStudio, you will be greeted by three panels: The Interactive R Console (entire left) *The top-left panel in RStudio is the script editor, where you write and save your code. When you run a line of code from the script, the output appears in the Console (bottom-left panel). While you can type and run code directly in the Console, it won’t be saved when you close R unless you explicitly save your R history. That’s why it’s best to write your code in the script editor—so you have a permanent, editable copy—and send lines to the Console to execute as needed. Environment/History (tabbed in upper right) Environment: collection of objects (i.e. variables, data frames, functions, etc.) that we define during our R session History: a record of every line of code executed during the session Files/Plots/Packages/Help/Viewer (tabbed in lower right) Files shows all the files in your working directory. A working directory is essentially the default folder that R is reading data from/putting output into. We will go through setting the working directory below. You can also create, delete, and rename files and folders from this tab. Plots displays figures that you generate Packages displays any packages you have downloaded and installed in R. If there is a check mark next to a package, it means you’ve loaded it into your current R session Help will show you a description of functions. To get a function description, simply run ? followed by the function name. For example, ?setwd() will show me the documentation for the setwd() function. Viewer displays interactive or web-based content Presentation displays slide-style documents created using R Markdown 2.4 RStudio Projects Now that we understand the basics of RStudio, let’s create an RStudio Project that will live in the directory folder of the analysis. RStudio Projects are a self-contained, portable work space where you can have your data, code, and output all in one place. RStudio Projects are also great to use for reproducibility because they are self-contained and easy to share with collaborators. This means you can compress the entire RStudio Project into a ZIP file and share it with a collaborator, who should then be able to run your code and reproduce the same results. Let’s go through how to set up an RStudio Project. Steps for Making an RProject Open the File menu from the upper left. Select Existing Directory since we have already set up our project’s directory Navigate to the directory folder Select Create Project Each time you open this RStudio project, the working directory is automatically set to the IntroR folder, where the project is saved. This means you don’t need to manually set the working directory, as RStudio Projects handle it for you, helping keep your files and code organized and consistent. For example, if my RStudio Project is located in C:/Teaching/IntroR/, my working directory is also located C:/Teaching/IntroR/. EXERCISE 2: CREATE AN RSTUDIO PROJECT Create an RStudio PRoject in your IntroR folder. Set a new editor theme. To change the editor theme, go to Tools &gt; Global Options, click on the Appearance tab, and choose a new editor theme from the list. Each theme will be previewed in the right window. "],["file.html", "Chapter 3 File paths 3.1 What is a file path? 3.2 Different separators between operating systems 3.3 Absolute and Relative file paths 3.4 Navigating outside the working directory 3.5 Using the Tab Shortcut in RStudio", " Chapter 3 File paths To manually set the working directory or load a file from a specific location, it’s important to understand how file paths work. 3.1 What is a file path? Your computer organizes files using a system of nested folders (i.e. directory structure), where each folder can contain other folders or files. Image from R for Epidemiology (https://www.r4epi.com) File paths are addresses to different locations (e.g. files, documents) within this nested framework. They represents the order of nested folders that the computer must go through to find that particular item. Each folder is separated by a slash. We can use Absolute or Relative file paths in R to locate files. Knowing the file path is important when you need to set your working directory. See this website for a detailed explanation. 3.2 Different separators between operating systems Different operating systems use different separators between folders of a file path. On windows, it is \\ On Mac/Linux, it is / R uses the / as the folder separator, even on Windows. So if you copy a file path from File Explorer (which uses ), be sure to either replace all backslashes () with forward slashes (/), or use double backslashes (\\) so R can read the path correctly. 3.3 Absolute and Relative file paths We can use Absolute or Relative file paths to give R directions to where we want to go. Absolute Paths: describe where a file is located relative to the root directory of the computer. This can be done on windows through right clicking the file path in windows explorer and selecting copy as text, or right clicking a file, holding the option key and selecting copy as path name on a macbook. Windows example: C:/Users/Documents/Teaching/IntroR/data/Intro-to-R-Workshop.csv Macbook example: /Users/lizsiemion/Documents/Teaching/IntroR/Intro-to-R-Workshop.csv Relative Paths: describe file location with respect to the current working directory. This just means that the file path starts with the location of the home directory. Windows example: IntroR/data/Intro-to-R-Workshop.csv Macbook example: IntroR/data/Intro-to-R-Workshop.csv ) It can be a bit cumbersome to work with absolute file paths. Since R Projects automatically sets the working directory as the project folder, we can use relative paths without any sort of additional set-up. Using relative paths also makes our code more readable, and easier to share and maintain. If we want to set our working directory manually, we can either use absolute or relative file paths. I recommend not changing the working directory within your script, as this can limit reproducibility. # check working directory getwd() # Assign working directory to new location using absolute path setwd(&quot;/Users/lizsiemion/Documents/teaching/Intro-to-R-Workshop&quot;) # Again, I do not recommend changing the working directory from an R project. 3.4 Navigating outside the working directory Let’s say we want to load a csv file into R that is outside of our working directory subfolders. How might we do that with absolute or relative paths from our current working directory? The absolute path is the full file path from our computer’s root directory. If we want to use the relative path, we need tell R to go up a given number of parent folder levels from a working directory, and then to the given location within that parent folder. This can be accomplished using ../ syntax. ./ tells R to go to the folder of the working directory ../ tells R to go to the parent folder of the working directory ../../ tells R to go to the parent folder of the parent folder of the working directory Let’s look at an example. Say our folder structure resembles the structure below and our RProject is located in the Intro-to-R-Workshop folder. Step 1: How many parent levels do we need to move up? Looks like we need to move up 1 level to the teaching folder ../, and another level up to the Documents folder ../. Step 2: Now that we are in the Documents folder, what is the relative path to to the example_file.txt? We need to go into the Coursework folder, and then the EcologyCenter folder, where example_file.txt is ultimately located. Coursework/EC-tidyverse-workshop-main/example_file.txt By combining steps 1 and 2, we’ve create the relative file path and can load the example_file.txt into our environment with read.csv(). read.csv(\"../../Coursework/ecologycenter/example_file.txt\") 3.5 Using the Tab Shortcut in RStudio The Tab shortcut in RStudio is a powerful shortcut that helps you write code faster and with fewer errors. It’s especially helpful for auto-completing file paths, function names, object names, and more. When you’re loading a file (e.g., using read.csv()), you can use the Tab key to help you find and insert the correct relative file path. For example: read.csv(\"data/ Then press the Tab key. A drop down list will appear showing the contents of the data/ folder (if it exists). You can then use the arrow keys to select a file and select Enter to insert it into the code. The Tab key shortcut helps avoid typos and ensures you’re referencing the correct file. EXERCISE 1: FILE PATHS Enter getwd() into the console to return the absolute file path Use a relative file path to load the bighorn capture table using read.csv(“TYPE_RELATIVE_FILE_PATH”). The read.csv() function tells R to load the CSV file into your Environment. Make sure the file path is placed inside quotes and within the parentheses. Tip: Try using the Tab key after typing the opening quote to help you navigate and generate the correct relative file path. "],["tidy-data.html", "Chapter 4 Tidy Data 4.1 Spreadsheets and Database Tables 4.2 Computer Readable Data 4.3 Tidy Data 4.4 Document 4.5 Rows for variables, columns for observations 4.6 Problemmatic Practices", " Chapter 4 Tidy Data 4.1 Spreadsheets and Database Tables 4.2 Computer Readable Data 4.3 Tidy Data Illustrations from the Openscapes blog Tidy Data for reproducibility, efficiency, and collaboration by Julia Lowndes and Allison Horst 4.4 Document 4.5 Rows for variables, columns for observations 4.6 Problemmatic Practices 4.6.1 Multiple tables in a single spreadsheet 4.6.2 Putting units in cells 4.6.3 Using Problematic Column Names 4.6.4 Zeros vs Missing Values 4.6.5 Using Problematic Null Values 4.6.6 Inconsistent Value Formatting "],["using-r.html", "Chapter 5 Using R 5.1 Installing Packages 5.2 Using Comments 5.3 Use R as a calculator 5.4 Use R to compare things 5.5 Use R to assign objects 5.6 Data Types (Modes) 5.7 Data Structure Classes 5.8 Functions 5.9 Indexing", " Chapter 5 Using R 5.1 Installing Packages Sometimes you will want to use tools that are not built into the baseR code. You can download these tools from R repositories as packages. A package is a collection of functions, data, and documentation bundled together for a specific function. An R package can help with tasks such as data visualization, statistical modeling, or data cleaning. You can install an R package through the RStudio interface, or through entering code into the console. install.packages(&quot;amt&quot;) # install a new package library(amt) # call a package you previously downloaded EXERCISE Load Tidyverse package using RStudio Select Packages Select Install Type tidyverse Select Install Bonus: Install tidyverse in the code editor using the example code above. We will go over what tidyverse is later on in this course If two different packages contain functions with the same name, R will mask one with the other based on the order they are loaded. To avoid confusion, you can explicitly tell R which package to use by using the package::function() format. For example, the filter() function exists in both stats and dplyr packages. If you specifically want the version from dplyr, you can write dplyr::filter() in your code. We will talk more about this later on. 5.2 Using Comments Use the # to tell R you are making a comment. Comments are used to explain code and allow someone unfamiliar with your code to follow more easily. Commenting can also be used to prevent R from running specific lines of code since R ignores anything that follows the # mark. # 567*5 tells R that 567*5 is a comment, and so R knows not to execute this line of code. Sometimes you want to comment out large sections of code, and this can be done using control + shift + c on windows or command + shift + c on a macbook. EXERCISE Create a new script (File &gt; New File &gt; R Script) In the first line, type # Intro R On line 2, type 1 + 1 Select Run in the upper right corner of the console. You can also use the shortcut control + enter on Windows and command + enter on a Macbook. If the keyboard shortcuts aren’t working, navigate to Tools &gt; Modify Keyboard Shortcuts , type Run Current Line or Section into the search bar, double-click the shortcut, remove the current key combination, and enter your preferred shortcut. 5.3 Use R as a calculator Remember, order of operations matters. The order is the same as you learned back in school. From highest to lowest precedence: Operator Symbol(s) Description Parentheses ( ) Controls the order of operations Exponents ^, ** Raises a number to a power Divide / Division Multiply * Multiplication Add + Addition Subtract - Subtraction 1 + 100 ## [1] 101 3 + 5 * 2 # performs multiplication before addition ## [1] 13 (3 + 5) * 2 # performs addition in () before multiplication ## [1] 16 2/10000 ## [1] 2e-04 2^3 ## [1] 8 5.4 Use R to compare things To compare things in R, we use logical operators. Below is a brief list. Operator Meaning == is equal to &gt; greater than &lt; less than &gt;= greater than or equal to &lt;= less than or equal to ! not | or %in% is contained in Let’s go through a few examples of using logical operators. Notice how R evaluates each of these lines of code as TRUE or FALSE. We are essentially asking R if the above comparison is TRUE or FALSE. We will go over %in% in the data organization section of this class. 1 == 9 # equality (note two equals signs, read as &quot;is equal to&quot;) ## [1] FALSE 1 != 1 # inequality (read as &quot;is not equal to&quot;) ## [1] FALSE 1 &lt; 2 # less than ## [1] TRUE 1 &lt;= 1 # less than or equal to ## [1] TRUE EXERCISE In your code editor, enter the following lines of code. Then run them to view each line of code’s output in your console. 67 * 9 7 + 9 + 10 4399 - 871 * (9 + 1) Evaluate whether the following logical conditions are TRUE or FALSE (380*3) == (190*6) 567 &gt; 890 30 &gt;= (27 + 1 + 2) Bonus: What is wrong with the following code? Type 87(9 + 1) into your console Execute that specific line of code by placing the cursor on that line and selecting Run. What error do you see? What do you think is happening? How might you fix this? 5.5 Use R to assign objects Objects are a bit of an abstract concept. All you really need to know for now is that objects are things that we make in R that can take on a variety of structures with different data types, and when we assign them a name, they get saved in our global environment. They are data structures with associated data attributes. Object assignment allows us to assign a variable name to the object for later use. This helps prevent writing redundant code. We assign an object to a variable using the assignment arrow &lt;- or the = so that R knows that x is an object that we can use. So when we run, x &lt;- 6, it reads make x contain 6 It’s recommended to use the &lt;- since the = can get mixed up with assigning values to function arguments (more on this later). Once we assign an object to a variable, it is stored in our global environment (upper right hand panel of RStudio). x &lt;- 1/40 # here we are telling R to assign 1/40 to the variable x so that it recognizes x as an object in our global environment x ## [1] 0.025 x = 24 # variables can easily be re-assigned/over-written y &lt;- x * 2 rm(y) # you can also remove objects from the environment 5.5.1 Variable names Variable names can contain letters, numbers, underscores and periods. They CANNOT start with a number OR contain spaces (at all). Remember that R is case sensitive. A few different conventions for longer variable names: periods.between.words underscores_between_words camelCaseToSeparateWords Your choice of convention is up to you, JUST BE CONSISTENT. EXERCISE Assign 1+56 to a variable called x1_a Assign sqrt(24) to a variable called x1_b Bonus: Chained assignments. What happens when you execute x3.c &lt;- y3.c &lt;- 9/10 into your console? Are x3.c and y3.c different or equal values? 5.6 Data Types (Modes) There are 6 main classes of common data modes (i.e. data types): numeric, character, logical, integer, complex, and factor. Data modes refers to the basic type of data stored in an object. For example, numeric mode stores numbers (integers or decimals), and character mode stores text. We typically only use factor, numeric, character, and logical data modes. Mode Description Example factor Categorical data “Sheep”, “Lion”, “Deer” numeric Numbers (includes integers and decimals) 3.14, 42 character Text strings “Lion180” logical TRUE or FALSE values TRUE, FALSE To ask R what class a data mode or object is, we use the class() function. class(1.11) # numeric: any real number class(1L) # integer: any integer. The L suffix forces the number to be an integer class(TRUE) # logical: binary TRUE or FALSE # You can have data that look essentially the same, but have different classes. class(&#39;1&#39;) # character: words; &quot;&quot; denote words class(1) # numeric; any real number class(factor(&quot;1a&quot;)) # factor: denotes categorical variables, they can be words or numbers You can coerce to a desired data type, as long as they follow the rules using the functions as.&lt;desired data type&gt; Coercian Hierarchy from general to specific: Logical -&gt; Numeric -&gt; Factor -&gt; Character logical (least general, cannot turn turn character or numeric into a logical type without correctly specifying the value) numeric (can read integer and logical types as numbers) character (most general: anything can be turned into a character by adding “quotes”) # Convert from numeric to integer a &lt;- 45.6 class(a) ## [1] &quot;numeric&quot; # Convert from numeric to character a_character &lt;- as.character(a) class(a_character) ## [1] &quot;character&quot; # Create factored variable lion &lt;- factor(c(&quot;194&quot;), levels = c(&quot;194&quot;)) lion # print value into console ## [1] 194 ## Levels: 194 as.numeric(lion) # coerced to numeric ## [1] 1 as.character(lion) # coerced to character ## [1] &quot;194&quot; as.numeric(as.character(lion)) # coerced to character, then numeric ## [1] 194 A common mistake in R is using data of the wrong type. In the example below, an error occurs because R cannot convert a character value into a numeric one. It’s important to ensure that the data you’re working with is of the correct type. Also, remember that each column in a data frame should contain values of the same type. # convert from character to numeric b &lt;- &quot;banana&quot; b_numeric &lt;- as.numeric(b) ## Warning: NAs introduced by coercion EXERCISE Assign \"S437\" to a variable called “sheep”. Make sure to include the \"\". What type of data class is sheep? Create an object with a value of 45. Coerce to a character class using as.character(). Execute S1 &lt;- as.numeric(as.character(1)) and S2 &lt;- as.logical(as.numeric(\"1\")). Do the values change? Why or why not? Think about this answer in the context of the coercian hierarchy. Bonus: What happens when you execute sheep &lt;- S437 without \"\"? Explain the error. 5.7 Data Structure Classes Remember when we talked about objects as data with attributes? Well, R offers several ways to store data, depending on what kind of structure you need. The most common types are vectors, data frames, and lists. Each of these can store different types of information and are useful in different contexts when working with data. Think of them as different types of containers for data that are designed to hold and organize data in specific ways. We will be discussing Scalar, Vector, Data Frames, Matrices, and Lists. Below is a summary of each of these data structures, and we will also go through each of these individually. Data Structure Description Can Contain Different Types? Dimensions Example Scalar A single value (a vector of length 1) No 1 (length = 1) x &lt;- 42 Vector A sequence of elements of the same type No 1 (length &gt; 1) c(1, 2, 3) Data Frame Table-like structure with columns of equal length Yes (by column) 2 (rows × cols) data.frame(a = 1:3, b = c(\"x\", \"y\", \"z\")) Matrix 2D array with all elements of the same type No 2 (rows × cols) matrix(1:6, nrow = 2) List A collection of elements that can be of different types Yes 1 (named or not) list(name = \"A\", age = 25, scores = c(1,2,3)) 5.7.1 Scalar A vector has one element with length 1. x &lt;- 3 EXERCISE 5.7.2 Vector A vector in R is essentially a collection of items of the same basic data type. Each ‘thing’ in the vector is called an element. If you don’t choose the data type, it’ll default to logical; or, you can declare an empty vector of whatever type you like. You can also make vectors with explicit contents using the concatenate function c(). my.deer &lt;- c(&quot;GDL256&quot;, &quot;RVD1011&quot;, &quot;CDB567&quot;) my_vector &lt;- vector(length = 3) my_vector # this is a logical vector ## [1] FALSE FALSE FALSE num_vector &lt;- c(101, 222, 323, 435, 556) # numeric vector # what happens when we add elements of different data types to a vector? combine_vector &lt;- c(211, &quot;CDB678&quot;, TRUE) combine_vector ## [1] &quot;211&quot; &quot;CDB678&quot; &quot;TRUE&quot; class(combine_vector) ## [1] &quot;character&quot; R interprets the whole vector as character. It can’t make “banana” into a number but it can turn 2 and TRUE into text strings. This logic follows the coercian hierarchy. You can also assign NA values to a vector of defined length as well. R is able to handle missing values, and these missing values are given NA. When you read in an csv file with empty cells, R will assign these values as NA. A 0 is not the same as NA, since R treats 0 as a numeric data class. x &lt;- rep(NA, 10) x[1] &lt;- 0 # test if zero is NA is.na(x) ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE We can also make a series of numbers using : or the seq() function. my_series &lt;- 1:10 # just integers my_series ## [1] 1 2 3 4 5 6 7 8 9 10 # make series of numbers from 1 to 10 by increments of 0.1 my_seq &lt;- seq(from = 1, to = 10, by = 0.1) my_seq ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 ## [16] 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 ## [31] 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 ## [46] 5.5 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 ## [61] 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 8.0 8.1 8.2 8.3 8.4 ## [76] 8.5 8.6 8.7 8.8 8.9 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 ## [91] 10.0 EXERCISE 5.7.3 Lists A list in R is essentially an object with data that can be in different data types/modes. # list with numeric, character, and logical classes my_list &lt;- list(1, &quot;banana&quot;, TRUE) your_list &lt;- list(2, &quot;apple&quot;, FALSE) my_list ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;banana&quot; ## ## [[3]] ## [1] TRUE # we can also append to a list with c() like we did to a vector my_list &lt;- c(my_list, c(&quot;Lion171&quot;, &quot;S222&quot;)) The $ is called the operator, and it is used for indexing named elements in a list. It allows you to access part of a data object for extracting or subsetting data. my_lions &lt;- list(&quot;L211&quot;, c(&quot;L194&quot;, &quot;S789&quot;), &quot;L180&quot;) names(my_lions) # are names automatically assigned? Nope, so let&#39;s assign names with the names() function. ## NULL names(my_lions) &lt;- c(&quot;Lion211&quot;, &quot;LionsAndSheep&quot;, &quot;Lion180&quot;) my_lions$LionsAndSheep ## [1] &quot;L194&quot; &quot;S789&quot; If you wanted to index a specific element in the list, you could also use brackets # index second list [[2]] and second element [2] of the second list my_lions[[2]][2] ## [1] &quot;S789&quot; EXERCISE 5.7.4 Matrix A matrix in R is a two-dimensional data structure that stores elements of the same type (usually numbers). You can think of it like a spreadsheet or a table with rows and columns, but every value must be the same type (e.g., all numeric or all character). Matrices are useful when you want to perform mathematical operations on tables of numbers, like multiplying rows and columns, or applying functions across rows or columns. MyMatrix &lt;- matrix(1:6, nrow = 2, ncol = 3) MyMatrix ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 EXERCISE 5.7.5 Data Frames A data frame in R is a like a list or generalized matrix but with the constraints that: all list elements are vectors (i.e. they have 1 mode), all vectors have the same length all columns (the list elements) have names Essentially, imagine each column in the dataframe as a vector, and the dataframe is just a big list of all those vectors. Unlike actual lists however, in dataframes all of the columns/vectors MUST be the same length and have names. # Create vectors for each column sheep_id &lt;- c(&quot;S601&quot;, &quot;S602&quot;, &quot;S603&quot;) sex &lt;- c(&quot;F&quot;, &quot;M&quot;, &quot;F&quot;) age &lt;- c(4, 6, 3) capt_date &lt;- as.Date(c(&quot;2024-03-15&quot;, &quot;2024-03-16&quot;, &quot;2024-03-18&quot;)) capt_loc &lt;- c(&quot;Acrodectes Peak&quot;, &quot;Sawmill Canyon&quot;, &quot;Goodale Canyon&quot;) # Combine into a data frame capt_dat &lt;- data.frame( ID = sheep_id, Sex = sex, Age = age, CaptureDate = capt_date, CaptureLoc = capt_loc, stringsAsFactors = FALSE # Ensures character columns are maintained as characters (not factors) ) # View the data frame print(capt_dat) ## ID Sex Age CaptureDate CaptureLoc ## 1 S601 F 4 2024-03-15 Acrodectes Peak ## 2 S602 M 6 2024-03-16 Sawmill Canyon ## 3 S603 F 3 2024-03-18 Goodale Canyon EXERCISE 5.7.6 Other Object Types R includes many other object types that we won’t cover in detail during this course. For instance, spatial object types are used to represent and work with geographic data. The specific structure depends on the package ecosystem—most commonly the older sp system or the more modern, tidyverse-friendly sf package. 5.8 Functions We’ve used several functions in the previous code. So what is a function? A function is a defined script that is used to accomplish a particular task. Functions use an input to give a desired output. Every function has arguments that determine what kind of inputs are needed to make the function run. The inputs in a function are called arguments. Arguments: information that goes inside the parenthesis to tell the function what to do. For example, when we used the seq function above, the arguments are from = 1, to = 10, and by = 0.1. Pass: We pass a value to a function argument. Above, we pass the value 1 to the argument from, and the value 10 to the argument to and the value 0.1 to the argument by Return: This is the terminology to say that the function gives us an output. So with the seq(from = 1, to = 10, by = 0.1), the function returns a sequence of numbers The order of arguments in a function call matters, especially when you don’t name them. To avoid confusion, it’s often helpful to explicitly name the arguments. You can use the help system to check the correct usage of a function. For example, to learn more about the rep() function, you can type ?rep in the Console. EXERCISE Use the ? function to look up the seq() function. Why does seq(from = 1, by = 3) return a sequence successfully, while seq(from = 40, by = 3) results in an error? What is causing the difference in behavior? 5.9 Indexing Indexing in R refers to the process of accessing specific elements from data structures like vectors, lists, or data frames. The type of indexing you use depends on the structure of your data and the task at hand, making it a versatile tool for data manipulation. To extract elements from a vector, use their index inside square brackets []. Indexing Method Description Example Positional Indexing Use numeric positions (1-based) to access elements in a vector, list, or data frame. my_vector[2] returns the 2nd element. Named Indexing Access elements by their name, making the code more readable. my_vector[\"b\"] returns the value associated with b. Logical Indexing Use a logical vector (TRUE/FALSE) to subset elements. Only elements corresponding to TRUE are selected. my_vector[c(TRUE, FALSE, TRUE)] returns elements where TRUE is present. Range Indexing Extract a range or sequence of elements using a colon or vector of indices. my_vector[2:4] returns elements from positions 2 to 4. Negative Indexing Exclude elements by using negative indices. my_vector[-2] excludes the 2nd element. Indexing with which() Find the indices of elements that satisfy a condition, and use those indices for subsetting. which(my_vector &gt; 20) returns indices where the values are greater than 20. 5.9.1 Numerical Indexing This method involves using the position of elements in a vector, list, or other data structures. R uses 1-based indexing, meaning the first element has an index of 1, not 0 (as in some other programming languages like Python or C). lion_list &lt;- c(&quot;194&quot;, &quot;228&quot;, &quot;267&quot;, &quot;272&quot;) lion_list[1] # extract first element out of the lion_list vector ## [1] &quot;194&quot; lion_list[4] # extract 4th element out of the lion_list vector ## [1] &quot;272&quot; lion_list[c(2:4)] # extract elements 2 to 4 from the my_seq vector ## [1] &quot;228&quot; &quot;267&quot; &quot;272&quot; 5.9.2 Named Indexing You can also extract elements by name rather than by index. Using names for indexing is particularly useful when you want to avoid relying on numeric positions, which may change as new data is added. horn_length &lt;- c(10, 30, 90, 50, 30) # create vector of horn lengths names(horn_length) &lt;- c(&quot;S4&quot;, &quot;S567&quot;, &quot;S489&quot;, &quot;S488&quot;, &quot;S89&quot;) # assign sheep names to vector # we can also name a vector &#39;on the fly&#39; horn_length &lt;- c(S4 = 5.4, S567 = 6.2, S489 = 7.1, S488 = 4.8, S89 = 7.5) horn_length[c(&quot;S489&quot;, &quot;S488&quot;)] ## S489 S488 ## 7.1 4.8 5.9.3 Logical Indexing Since comparison operators (e.g. &gt;, &lt;, ==) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one. This involves using logical vectors (TRUE/FALSE) to index elements. The logical vector must be of the same length as the data structure you’re indexing. Only elements corresponding to TRUE are selected. horn_length[horn_length &gt; 30] # this statement first evaluates horn_length &gt; 7, generating a logical vector c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of horn_length corresponding to the TRUE values. ## named numeric(0) 5.9.4 Range or Sequence Indexing You can extract a range or sequence of elements using a colon : to specify a range or a vector of indices. horn_length[1:3] ## S4 S567 S489 ## 5.4 6.2 7.1 5.9.5 Negative Indexing Negative indexing is used to exclude elements from a data structure. When you use a negative index, R excludes the element at that specific position. Note that negative indexing only applies to numeric positions, not named elements. horn_length[-2] ## S4 S489 S488 S89 ## 5.4 7.1 4.8 7.5 # we can skip multiple elements horn_length[c(-1, -2)] ## S489 S488 S89 ## 7.1 4.8 7.5 # or horn_length[-c(1,5)] ## S567 S489 S488 ## 6.2 7.1 4.8 # a common mistake would be to ask R x[-1:3] # but there isn&#39;t a negative first row # But remember the order of operations. # : is really a function. It takes its first argument as -1, # and its second as 3, so generates the sequence of # numbers: c(-1, 0, 1, 2, 3). horn_length[-(1:3)] ## S488 S89 ## 4.8 7.5 # To remove elements from a vector, we need to assign the result # back into the variable: horn_length &lt;- horn_length[-4] horn_length ## S4 S567 S489 S89 ## 5.4 6.2 7.1 7.5 5.9.6 Which Indexing The which() function returns the indices of elements that satisfy a given condition (useful in combination with logical operations). EXERCISE 5.9.7 Indexing different data types Different object types in R require distinct indexing syntax, as each type has its own structure and behavior. For instance, vectors are indexed using [], while lists require [[]] to extract individual elements. Data frames can be subsetted using both [] and [[]], but the syntax varies depending on whether you’re accessing rows, columns, or individual elements. Understanding the proper indexing method for each object type is crucial for effectively manipulating and extracting data in R. Data Structure Indexing with [] Indexing with [[]] Description Vector my_vector[2] - Accesses the 2nd element. Not applicable (use [] for vectors). [] returns a subset (vector), and [] is used to extract individual elements by their position. Data Frame my_df[2, ] - Accesses the 2nd row (returns a data frame). my_df[[2]] - Accesses the 2nd column (returns a vector). [] keeps the result as a data frame, while [[]] extracts a specific column or element. Matrix my_matrix[2, 3] - Accesses the element in the 2nd row and 3rd column. Not applicable (use [] for matrices). [] is used to index both rows and columns, but [[]] is not used with matrices. List my_list[2] - Returns the 2nd element of the list (as a list). my_list[[2]] - Returns the 2nd element of the list (as the actual object, not as a list). [] returns a sublist, while [[]] extracts the actual object at that index. List of Lists my_list_of_lists[2] - Returns the 2nd list in the list of lists (as a list). my_list_of_lists[[2]] - Returns the 2nd list (the entire list, not just an element). [] returns a sublist, while [[]] extracts the entire second list when using a list of lists. Nested List my_list[[2]][[2]] - Returns the 2nd element of the 2nd list in the list of lists (after first subsetting). my_list[[2]][[2]] - Extracts the 2nd element from the 2nd list in the list. [] can be used to subset lists, and [[]] extracts elements within the nested list structure. EXERCISE "],["tidyverse.html", "Chapter 6 Tidyverse 6.1 Why Tidyverse? 6.2 Main dplyr functions: 6.3 GGPLOT2", " Chapter 6 Tidyverse 6.1 Why Tidyverse? The tidyverse is a collection of R packages designed to simplify and streamline data science tasks. It promotes the concept of “tidy data,” where each column is a variable and each row is an observation, which simplifies analysis and visualization. Core tidyverse packages include ggplot2 for plotting, dplyr for data manipulation, and tidyr for reshaping data. One of the key strengths of the tidyverse is its readable syntax, especially with the use of the pipe operator (%&gt;%), which allows users to chain together multiple steps in a clear, logical order. Learning the tidyverse equips beginners with practical tools and workflows that are essential for modern data analysis in R. One of the most commonly used packages within the tidyverse is dplyr (data plier), which provides a set of powerful and intuitive functions for manipulating data frames. With dplyr, you can easily filter rows, select columns, create new variables, group data, and summarize it—all using clear, readable code. Key Features: Consistent syntax across packages, making code easier to write and read. Tidy data structure, where each variable is a column and each observation is a row. Readable workflows using the pipe operator (%&gt;%) to chain commands clearly. Integrated tools for the entire data science process—importing, cleaning, transforming, visualizing, and modeling data. User-friendly functions with intuitive names and logical default argument values. Open-source and widely supported, with ample online learning resources Provides tools for data manipulation, exploration, and visualization. Uses piping (%&gt;%) to create readable, fluent workflows (through the magrittr package) 6.2 Main dplyr functions: dplyr, a main package of the tidyverse, consists of five main functions: filter() select() mutate() summarize() arrange() group_by() Add example code here. EXERCISE 1 (Use filter to…) (Use mutate to…) (Select x columns) (group by sheep and summarize data) 6.3 GGPLOT2 ggplot2 is a powerful and flexible R package used for data visualization. It is part of the tidyverse and is built on the Grammar of Graphics—a layered approach to building plots that allows you to combine data, visual elements, and aesthetics step by step. Key Features Layered plotting system: Build plots by adding layers (e.g., points, lines, bars). Aesthetic mapping: Easily map variables to visual properties like color, size, and shape. Customizable: Control themes, labels, scales, and more for polished, publication-ready graphics. Works seamlessly with tidy data and other tidyverse tools. Example of using ggplot to plot some bighorn thing EXERCISE 2 1. "],["import-export.html", "Chapter 7 Importing and Exporting data files 7.1 Load and export basic files 7.2 Connect to a database on Windows OS 7.3 Load database files on a Macbook", " Chapter 7 Importing and Exporting data files 7.1 Load and export basic files csv, xlsx, mdb, rds EXERCISE 7.2 Connect to a database on Windows OS 7.3 Load database files on a Macbook EXERCISE "],["data-org.html", "Chapter 8 Data Organization 8.1 Exploring Data Frames 8.2 Vectorized Operations 8.3 Data Frame Manipulation 8.4 Subsetting 8.5 ifelse Statements", " Chapter 8 Data Organization Let’s start by downloading some data and exploring it in a data frame. In this example, we’ll load a CSV file. We’ll cover how to import and export different types of data files in more detail later. mort &lt;- read.csv(&quot;./docs/data/BighornMortTable.csv&quot;) 8.1 Exploring Data Frames Let’s take a look at the data. Exploring your dataset is one of the most important first steps when working in R. It helps you understand the structure, types of variables, and potential issues before doing any analysis. A good place to start is by examining the structure of the data to see what you’re working with. # str() shows us the structure of the data, including the data mode, # the dimensions of # the dataframe including the data mode, the dimensions of # the dataframe, and a few observations str(mort) ## &#39;data.frame&#39;: 1061 obs. of 45 variables: ## $ NecropDateDt : chr &quot;31-Jan-25&quot; &quot;21-Jan-25&quot; &quot;05-Jan-25&quot; &quot;08-Sep-24&quot; ... ## $ NecropDate : int 20250131 20250121 20250105 20240908 20240709 20240617 20240604 20240530 20240528 20240520 ... ## $ DeadDateDt : chr &quot;22-Jan-25&quot; &quot;25-Jun-23&quot; &quot;02-Dec-24&quot; &quot;26-Feb-17&quot; ... ## $ DeadDate : int 20250122 20230625 20241202 20170226 20240311 20240308 20230925 20240127 20240101 20240430 ... ## $ Date1stHeardDt : chr &quot;30-Jan-25&quot; &quot;&quot; &quot;02-Dec-24&quot; &quot;&quot; ... ## $ Date1stHeard : int 20250130 NA 20241202 NA 20240508 20240308 20230925 20240127 20240101 20240430 ... ## $ AgeCarcass : int 9 583 33 NA 120 NA 254 123 120 21 ... ## $ BestDead : int NA NA 20241202 20170226 20240311 20240308 20230925 20240127 20240101 20240430 ... ## $ AnimalYear : int NA NA 2024 2016 2023 2023 2023 2023 2023 2023 ... ## $ Recorder : chr &quot;C_Massing&quot; &quot;M_Christopher&quot; &quot;L_Greene&quot; &quot;L_Greene&quot; ... ## $ Herd : chr &quot;Mt. Williamson&quot; &quot;Mt. Baxter&quot; &quot;Mt. Gibbs&quot; &quot;Mt. Langley&quot; ... ## $ Animal_ID : chr &quot;M267&quot; &quot;M266&quot; &quot;M265&quot; &quot;S217&quot; ... ## $ Sex : chr &quot;Male&quot; &quot;Male&quot; &quot;Unknown&quot; &quot;Male&quot; ... ## $ Age : chr &quot;6&quot; &quot;11&quot; &quot;0&quot; &quot;5&quot; ... ## $ AgeEstMethod : chr &quot;Horn Rings&quot; &quot;Horn Rings&quot; &quot;Size of Remains&quot; &quot;Horn Rings&quot; ... ## $ GPS_CollarSerialNo_Date_FK: chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ CollarSN : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ VHF_freq : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ Location : chr &quot;On Shepherd Pass trail, 1 mi up from TH, ~6800ft elevation&quot; &quot;Sand Mtn&quot; &quot;Gibbs, S side&quot; &quot;Hitchcock Ridge, near rainbow camp&quot; ... ## $ InvestReason : chr &quot;Opportunistic&quot; &quot;Opportunistic&quot; &quot;Lion Cluster&quot; &quot;opportunistic&quot; ... ## $ UTM_E : int 384668 384854 306232 378981 299699 352085 399881 352786 349902 381814 ... ## $ UTM_N : int 4067085 4085215 4193944 4046150 4216718 4142608 4012253 4149065 4144062 4079364 ... ## $ ElevDEM : int NA NA NA NA NA NA NA NA NA NA ... ## $ CarcassCon : chr &quot;Consumed&quot; &quot;Consumed&quot; &quot;Consumed&quot; &quot;Scavenged&quot; ... ## $ Cause_Mort : chr &quot;Lion&quot; &quot;Unknown&quot; &quot;Lion&quot; &quot;Unknown not Predation&quot; ... ## $ CausMortAcc : chr &quot;Certain&quot; &quot;&quot; &quot;Certain&quot; &quot;Certain&quot; ... ## $ ConditionNotes : chr &quot;skeleton intact, ribs clipped, eaten, most meat eaten but not all, legs with hair still intact&quot; &quot;old carcass, bleached bones, still close together, complete skull attached to spine, couple loose ribs, jaw, pelvis&quot; &quot;rumen and lower leg, snow may have covered some remains&quot; &quot;bone fragments and skull. Not in avalanche path, not cached&quot; ... ## $ Evidence : chr &quot;rumen intact, ribs clipped, hair plucked.&quot; &quot;could be lion, clipped ribs, broken pelvis, leg bones chewed, all bones clost together, but it is all too old to be sure&quot; &quot;lion cluster, broken long bones, rumen intact&quot; &quot;this ribs still attached to backbone, some gnawed off but not clipped.&quot; ... ## $ Comments : chr &quot;Lion could have scavenged dead sheep. Sheep on trail, not below cliff. Collected scat in possible latrine, it w&quot;| __truncated__ &quot;estimated date of death based on condition of bones, very unknown but skeleton still there and mostly intact&quot; &quot;metarsus measured ~21cm which could be very small adult or more likely lamb&quot; &quot;Originally censored but found opportunistically with collar and eartag. Bones starting to get crumbly, may have&quot;| __truncated__ ... ## $ CauseMortRevised : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ RevisionReason : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ PhotoTaken : chr &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; &quot;&quot; ... ## $ Houndsmen : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ RumenIntact : chr &quot;Y&quot; &quot;N&quot; &quot;Y&quot; &quot;&quot; ... ## $ TracksFound : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;&quot; ... ## $ ScatFound : chr &quot;&quot; &quot;N&quot; &quot;&quot; &quot;&quot; ... ## $ DragMarks : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;&quot; ... ## $ Latrine : chr &quot;&quot; &quot;N&quot; &quot;&quot; &quot;&quot; ... ## $ Femur : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;n&quot; ... ## $ Tooth : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;n&quot; ... ## $ Mandible : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;n&quot; ... ## $ Skull : chr &quot;N&quot; &quot;N&quot; &quot;&quot; &quot;n&quot; ... ## $ LionID : chr &quot;&quot; &quot;&quot; &quot;267&quot; &quot;&quot; ... ## $ KillLocUsingGPSData : chr &quot;N&quot; &quot;N&quot; &quot;Y&quot; &quot;n&quot; ... ## $ LionClusterID : chr &quot;&quot; &quot;&quot; &quot;267_20241202&quot; &quot;&quot; ... length(mort) # gives the number of columns ## [1] 45 nrow(mort) # to get the number of rows ## [1] 1061 ncol(mort) # number of columns ## [1] 45 dim(mort) # or both at once, dim() ## [1] 1061 45 names(mort) # names of the columns ## [1] &quot;NecropDateDt&quot; &quot;NecropDate&quot; ## [3] &quot;DeadDateDt&quot; &quot;DeadDate&quot; ## [5] &quot;Date1stHeardDt&quot; &quot;Date1stHeard&quot; ## [7] &quot;AgeCarcass&quot; &quot;BestDead&quot; ## [9] &quot;AnimalYear&quot; &quot;Recorder&quot; ## [11] &quot;Herd&quot; &quot;Animal_ID&quot; ## [13] &quot;Sex&quot; &quot;Age&quot; ## [15] &quot;AgeEstMethod&quot; &quot;GPS_CollarSerialNo_Date_FK&quot; ## [17] &quot;CollarSN&quot; &quot;VHF_freq&quot; ## [19] &quot;Location&quot; &quot;InvestReason&quot; ## [21] &quot;UTM_E&quot; &quot;UTM_N&quot; ## [23] &quot;ElevDEM&quot; &quot;CarcassCon&quot; ## [25] &quot;Cause_Mort&quot; &quot;CausMortAcc&quot; ## [27] &quot;ConditionNotes&quot; &quot;Evidence&quot; ## [29] &quot;Comments&quot; &quot;CauseMortRevised&quot; ## [31] &quot;RevisionReason&quot; &quot;PhotoTaken&quot; ## [33] &quot;Houndsmen&quot; &quot;RumenIntact&quot; ## [35] &quot;TracksFound&quot; &quot;ScatFound&quot; ## [37] &quot;DragMarks&quot; &quot;Latrine&quot; ## [39] &quot;Femur&quot; &quot;Tooth&quot; ## [41] &quot;Mandible&quot; &quot;Skull&quot; ## [43] &quot;LionID&quot; &quot;KillLocUsingGPSData&quot; ## [45] &quot;LionClusterID&quot; It’s a good time to ask ourselves if the structure R is reporting matches our intuition: Does the data type for each column make sense? If not, we need to sort out those issues now so we Don’t run into issues down the road. Once we’re happy with our data types, we can really start digging into our data! We can also examine individual columns: class(mort$AnimalYear) ## [1] &quot;integer&quot; class(mort$Animal_ID) ## [1] &quot;character&quot; str(mort$Cause_Mort) ## chr [1:1061] &quot;Lion&quot; &quot;Unknown&quot; &quot;Lion&quot; &quot;Unknown not Predation&quot; &quot;Lion&quot; ... We can also index a dataframe column using the operator. mort$Animal_ID[1] ## [1] &quot;M267&quot; We can use the functions head() and tail() to look at the first or last 6 rows of the data frame. head(mort, n = 3) # n = refers to how many rows to print ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 ## 2 21-Jan-25 20250121 25-Jun-23 20230625 NA ## 3 05-Jan-25 20250105 02-Dec-24 20241202 02-Dec-24 20241202 ## AgeCarcass BestDead AnimalYear Recorder Herd Animal_ID Sex ## 1 9 NA NA C_Massing Mt. Williamson M267 Male ## 2 583 NA NA M_Christopher Mt. Baxter M266 Male ## 3 33 20241202 2024 L_Greene Mt. Gibbs M265 Unknown ## Age AgeEstMethod GPS_CollarSerialNo_Date_FK CollarSN VHF_freq ## 1 6 Horn Rings ## 2 11 Horn Rings ## 3 0 Size of Remains ## Location InvestReason ## 1 On Shepherd Pass trail, 1 mi up from TH, ~6800ft elevation Opportunistic ## 2 Sand Mtn Opportunistic ## 3 Gibbs, S side Lion Cluster ## UTM_E UTM_N ElevDEM CarcassCon Cause_Mort CausMortAcc ## 1 384668 4067085 NA Consumed Lion Certain ## 2 384854 4085215 NA Consumed Unknown ## 3 306232 4193944 NA Consumed Lion Certain ## ConditionNotes ## 1 skeleton intact, ribs clipped, eaten, most meat eaten but not all, legs with hair still intact ## 2 old carcass, bleached bones, still close together, complete skull attached to spine, couple loose ribs, jaw, pelvis ## 3 rumen and lower leg, snow may have covered some remains ## Evidence ## 1 rumen intact, ribs clipped, hair plucked. ## 2 could be lion, clipped ribs, broken pelvis, leg bones chewed, all bones clost together, but it is all too old to be sure ## 3 lion cluster, broken long bones, rumen intact ## Comments ## 1 Lion could have scavenged dead sheep. Sheep on trail, not below cliff. Collected scat in possible latrine, it was liquid (had dried), hard to know if it was lion scat. Lion hairs found in bed near carcass. Snow fell 5 days before and did not find clear tracks around carcass other than human and canine. ## 2 estimated date of death based on condition of bones, very unknown but skeleton still there and mostly intact ## 3 metarsus measured ~21cm which could be very small adult or more likely lamb ## CauseMortRevised RevisionReason PhotoTaken Houndsmen RumenIntact TracksFound ## 1 Y Y N ## 2 Y N N ## 3 Y Y ## ScatFound DragMarks Latrine Femur Tooth Mandible Skull LionID ## 1 N N N N N ## 2 N N N N N N N ## 3 267 ## KillLocUsingGPSData LionClusterID ## 1 N ## 2 N ## 3 Y 267_20241202 Similarly, [[ will act to extract a single column: mort[[&quot;AnimalYear&quot;]][500] # extract the 500th row of the AnimalYear column ## [1] 2016 We can also use square brackets to extract specific elements from a data frame. Remember that data frame indexing follows the format [rows, columns], so the first number refers to the row, and the second to the column. # [rows, columns] mort[1,2] # grab element at first row and second column ## [1] 20250131 mort[1,1:6] # grab row 1 in columns 1-6 ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 mort[1:6,5] # grab row 1-6 in column 5 ## [1] &quot;30-Jan-25&quot; &quot;&quot; &quot;02-Dec-24&quot; &quot;&quot; &quot;08-May-24&quot; &quot;08-Mar-24&quot; mort[1:6,1:6] # grab row 1-6 in columns 1-6 ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 ## 2 21-Jan-25 20250121 25-Jun-23 20230625 NA ## 3 05-Jan-25 20250105 02-Dec-24 20241202 02-Dec-24 20241202 ## 4 08-Sep-24 20240908 26-Feb-17 20170226 NA ## 5 09-Jul-24 20240709 11-Mar-24 20240311 08-May-24 20240508 ## 6 17-Jun-24 20240617 08-Mar-24 20240308 08-Mar-24 20240308 head(mort[,1:3], n = 5) # grab all rows from columns 1-3, show me the first 5 rows ## NecropDateDt NecropDate DeadDateDt ## 1 31-Jan-25 20250131 22-Jan-25 ## 2 21-Jan-25 20250121 25-Jun-23 ## 3 05-Jan-25 20250105 02-Dec-24 ## 4 08-Sep-24 20240908 26-Feb-17 ## 5 09-Jul-24 20240709 11-Mar-24 8.2 Vectorized Operations R is a natively vectorized language, which means it can automatically perform operations on entire vectors (columns of data) without the need for explicit loops. This makes data manipulation in R efficient and concise. For example, let’s say all the ages in our bighorn mortality dataset are off by one year. To correct this, we can simply add 1 to the entire Age column. This works because R applies the operation to each element of the vector. But first, we need to make sure the Age column is numeric. If it’s stored as character or factor, we need to coerce it to numeric before performing the math. Because R vectorizes math operations, the + 1 is automatically applied to every value in the Age column, and the result is stored in the new AgeNew column—no loop required. class(mort$Age) ## [1] &quot;character&quot; mort$AgeNew &lt;- as.numeric(mort$Age) ## Warning: NAs introduced by coercion mort$AgeNew &lt;- mort$AgeNew + 1 We see a warning about NAs being introduced when coercing values to a numeric data type. This happens because some entries in the Age column aren’t purely numeric—for example, values like “4+” or “&gt;7” contain extra characters. Since R can’t interpret these as numbers, it replaces them with NA. In practice, we could clean this column so it contains only numeric values. One way to do that is by using the gsub() function along with a regular expression to remove non-numeric characters. I’ll show you the code below for reference, but we won’t be covering regular expressions in detail during this workshop. mort$AgeNew &lt;- gsub(&quot;[^0-9.]&quot;, &quot;&quot;, mort$Age) # Remove all non-numeric characters mort$AgeNew &lt;- as.numeric(mort$AgeNew) # Coerce from character to numeric data mode head(mort$AgeNew, n = 10) ## [1] 6 11 0 5 4 9 0 3 10 2 mort$AgeNew &lt;- mort$AgeNew + 1 head(mort$AgeNew, n = 10) ## [1] 7 12 1 6 5 10 1 4 11 3 8.3 Data Frame Manipulation Let’s create a new column to hold information on whether bighorn age is &lt; 5: below_five &lt;- mort$Age &lt; 5 head(below_five) ## [1] FALSE TRUE TRUE FALSE TRUE FALSE We’ve created a simple vector of TRUE/FALSE values. To add it to our data frame, we can use the cbind() function, which binds columns together. In this case, it combines our existing data frame with the new logical vector as an additional column. mort &lt;- cbind(mort, below_five) head(cbind(mort, below_five), 3) ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 ## 2 21-Jan-25 20250121 25-Jun-23 20230625 NA ## 3 05-Jan-25 20250105 02-Dec-24 20241202 02-Dec-24 20241202 ## AgeCarcass BestDead AnimalYear Recorder Herd Animal_ID Sex ## 1 9 NA NA C_Massing Mt. Williamson M267 Male ## 2 583 NA NA M_Christopher Mt. Baxter M266 Male ## 3 33 20241202 2024 L_Greene Mt. Gibbs M265 Unknown ## Age AgeEstMethod GPS_CollarSerialNo_Date_FK CollarSN VHF_freq ## 1 6 Horn Rings ## 2 11 Horn Rings ## 3 0 Size of Remains ## Location InvestReason ## 1 On Shepherd Pass trail, 1 mi up from TH, ~6800ft elevation Opportunistic ## 2 Sand Mtn Opportunistic ## 3 Gibbs, S side Lion Cluster ## UTM_E UTM_N ElevDEM CarcassCon Cause_Mort CausMortAcc ## 1 384668 4067085 NA Consumed Lion Certain ## 2 384854 4085215 NA Consumed Unknown ## 3 306232 4193944 NA Consumed Lion Certain ## ConditionNotes ## 1 skeleton intact, ribs clipped, eaten, most meat eaten but not all, legs with hair still intact ## 2 old carcass, bleached bones, still close together, complete skull attached to spine, couple loose ribs, jaw, pelvis ## 3 rumen and lower leg, snow may have covered some remains ## Evidence ## 1 rumen intact, ribs clipped, hair plucked. ## 2 could be lion, clipped ribs, broken pelvis, leg bones chewed, all bones clost together, but it is all too old to be sure ## 3 lion cluster, broken long bones, rumen intact ## Comments ## 1 Lion could have scavenged dead sheep. Sheep on trail, not below cliff. Collected scat in possible latrine, it was liquid (had dried), hard to know if it was lion scat. Lion hairs found in bed near carcass. Snow fell 5 days before and did not find clear tracks around carcass other than human and canine. ## 2 estimated date of death based on condition of bones, very unknown but skeleton still there and mostly intact ## 3 metarsus measured ~21cm which could be very small adult or more likely lamb ## CauseMortRevised RevisionReason PhotoTaken Houndsmen RumenIntact TracksFound ## 1 Y Y N ## 2 Y N N ## 3 Y Y ## ScatFound DragMarks Latrine Femur Tooth Mandible Skull LionID ## 1 N N N N N ## 2 N N N N N N N ## 3 267 ## KillLocUsingGPSData LionClusterID AgeNew below_five below_five ## 1 N 7 FALSE FALSE ## 2 N 12 TRUE TRUE ## 3 Y 267_20241202 1 TRUE TRUE head(mort, 3) ## NecropDateDt NecropDate DeadDateDt DeadDate Date1stHeardDt Date1stHeard ## 1 31-Jan-25 20250131 22-Jan-25 20250122 30-Jan-25 20250130 ## 2 21-Jan-25 20250121 25-Jun-23 20230625 NA ## 3 05-Jan-25 20250105 02-Dec-24 20241202 02-Dec-24 20241202 ## AgeCarcass BestDead AnimalYear Recorder Herd Animal_ID Sex ## 1 9 NA NA C_Massing Mt. Williamson M267 Male ## 2 583 NA NA M_Christopher Mt. Baxter M266 Male ## 3 33 20241202 2024 L_Greene Mt. Gibbs M265 Unknown ## Age AgeEstMethod GPS_CollarSerialNo_Date_FK CollarSN VHF_freq ## 1 6 Horn Rings ## 2 11 Horn Rings ## 3 0 Size of Remains ## Location InvestReason ## 1 On Shepherd Pass trail, 1 mi up from TH, ~6800ft elevation Opportunistic ## 2 Sand Mtn Opportunistic ## 3 Gibbs, S side Lion Cluster ## UTM_E UTM_N ElevDEM CarcassCon Cause_Mort CausMortAcc ## 1 384668 4067085 NA Consumed Lion Certain ## 2 384854 4085215 NA Consumed Unknown ## 3 306232 4193944 NA Consumed Lion Certain ## ConditionNotes ## 1 skeleton intact, ribs clipped, eaten, most meat eaten but not all, legs with hair still intact ## 2 old carcass, bleached bones, still close together, complete skull attached to spine, couple loose ribs, jaw, pelvis ## 3 rumen and lower leg, snow may have covered some remains ## Evidence ## 1 rumen intact, ribs clipped, hair plucked. ## 2 could be lion, clipped ribs, broken pelvis, leg bones chewed, all bones clost together, but it is all too old to be sure ## 3 lion cluster, broken long bones, rumen intact ## Comments ## 1 Lion could have scavenged dead sheep. Sheep on trail, not below cliff. Collected scat in possible latrine, it was liquid (had dried), hard to know if it was lion scat. Lion hairs found in bed near carcass. Snow fell 5 days before and did not find clear tracks around carcass other than human and canine. ## 2 estimated date of death based on condition of bones, very unknown but skeleton still there and mostly intact ## 3 metarsus measured ~21cm which could be very small adult or more likely lamb ## CauseMortRevised RevisionReason PhotoTaken Houndsmen RumenIntact TracksFound ## 1 Y Y N ## 2 Y N N ## 3 Y Y ## ScatFound DragMarks Latrine Femur Tooth Mandible Skull LionID ## 1 N N N N N ## 2 N N N N N N N ## 3 267 ## KillLocUsingGPSData LionClusterID AgeNew below_five ## 1 N 7 FALSE ## 2 N 12 TRUE ## 3 Y 267_20241202 1 TRUE If we try to add the below_average vector to our data frame but it has a different number of elements than there are rows in the data frame, R will return an error. The number of entries must match for the columns to align correctly. below_five &lt;- c(TRUE, TRUE, TRUE, TRUE, TRUE) head(cbind(mort, below_five)) Now let’s look at how we might add rows to a data frame. # first let&#39;s make a mortality dataframe of 3 columns mort_short &lt;- mort[,c(&quot;Animal_ID&quot;, &quot;Age&quot;, &quot;Cause_Mort&quot;)] new_row &lt;- list(&#39;S781&#39;, 3, &quot;Lion&quot;) # note that we have to make the row a list, since each column has a different data type mort_new &lt;- rbind(mort_short, new_row) tail(mort_new) # lets you look at the last 6 lines of data EXERCISE 1. vector vs df vs list in adding a new row what works? 8.4 Subsetting 8.5 ifelse Statements "],["functional.html", "Chapter 9 Functional Programming 9.1 Control Structures 9.2 For Loops 9.3 Troubleshooting For-loops", " Chapter 9 Functional Programming 9.1 Control Structures Indenting 9.2 For Loops Indenting Easy for loop is to get mean weight by herd, or something like that. This will be a for-loop related to whatever basic statistical analysis we are doing. EXERCISE 9.3 Troubleshooting For-loops "],["plotting.html", "Chapter 10 Basic Plotting 10.1 load bighorn capture table 10.2 Organize data 10.3 BaseR Plotting 10.4 BaseR scatterplot 10.5 ggplot2", " Chapter 10 Basic Plotting 10.1 load bighorn capture table 10.2 Organize data 10.3 BaseR Plotting 10.4 BaseR scatterplot scatterplot: x = herd; y = horn length; color by herd 10.5 ggplot2 barplot: x = herd; y = horn length; color by sex EXERCISE Organize data. This will require making sure the data structure is the correct type. Create a BaseR barplot: x = herd; y = weight; color by sex Create a ggplot2 scatterplot x = herd; y = weight; color by weight "],["statistical-summaries.html", "Chapter 11 Statistical Summaries 11.1 Look at summary of weight data 11.2 plot bighorn weight using ggplot2 11.3 Statistical Analysis 11.4 Plot Results", " Chapter 11 Statistical Summaries 11.1 Look at summary of weight data 11.2 plot bighorn weight using ggplot2 11.3 Statistical Analysis Compare if bighorn weights differ between Gibbs and Baxter using a T-test 11.4 Plot Results "],["debugging.html", "Chapter 12 Debugging Code 12.1 Locating Problematic Code 12.2 Syntax errors 12.3 Coercian Problems 12.4 Labeling function arguments 12.5 Conflicting Functions 12.6 Use the Help ? Function! 12.7 Google 12.8 AI", " Chapter 12 Debugging Code Artwork by Allison Horst Even when you know R well, you will inevitably find yourself in situations where you don’t understand how a package works, encounter an unexpected error, aren’t sure which function to use, or need ideas for how to write the correct code. This is a normal part of coding and problem-solving. Experienced R users frequently search documentation, check forums like Stack Overflow, read vignettes, and experiment with small pieces of code to troubleshoot issues or explore new approaches. The key is knowing how to identify the problematic code, ask good questions, and know where to look for help. 12.1 Locating Problematic Code If your code throws an error, begin by finding the line where it occurs. Run your code one line at a time until the error shows up. If the issue isn’t clear on that line, break it into smaller parts and test each section individually. This step-by-step process helps you pinpoint the exact source of the problem. EXERCISE 1 Trouble shoot the following code. x &lt;- c(1, 2, 3) y &lt;- c(4, 5, \"six\") result &lt;- x + y 12.2 Syntax errors Check Your Parenthesis! A common error in R occurs when parentheses are not properly balanced. Every opening parenthesis ( must have a corresponding closing parenthesis ). If they don’t match, R will throw an error or hang while waiting for the rest of the expression to be executed. For example, mean(c(1, 3, 5, 6)) works correctly because the parentheses are balanced, while mean(c(1, 3, 5, 6) will result in an error due to the missing closing parenthesis. R will highlight the matching parenthesis when you place your cursor just before an opening ( or just after a closing ), helping you check that your parentheses are properly balanced. Check your commas! In R, syntax errors related to commas often occur when they are either missing or misplaced. Commas are used to separate function arguments or elements in vectors, lists, and other data structures. A missing comma can cause R to misinterpret the code, leading to errors. EXERCISE 2 Trouble shoot the following code. Start by running each line of code to understand where the error occurs. x &lt;- c(1, 2, 3 y &lt;- c(4, 5 \"six\") 12.3 Coercian Problems In R, coercion occurs when elements of different types are combined, and R automatically converts them to a common type to maintain consistency. This can lead to unintended results if not handled carefully. Always check your data types with str(), typeof(), or classs() to avoid coercion issues. A common coercion error in R occurs when you convert a factor to numeric without first converting it to a character. Doing as.numeric() directly on a factor returns the internal integer codes of the factor levels, not the actual numeric values you might expect. f &lt;- factor(c(&quot;10&quot;, &quot;20&quot;, &quot;30&quot;)) # incorrect coercian as.numeric(f) ## [1] 1 2 3 # correct coercian as.numeric(as.character(f)) ## [1] 10 20 30 12.4 Labeling function arguments Labeling function arguments in R improves clarity and reduces errors. While you can pass arguments by position (e.g., seq(1, 10, 2)), naming them explicitly (e.g., seq(from = 1, to = 10, by = 2)) makes your code easier to read and avoids mistakes—especially when argument order is unclear or changes. 12.5 Conflicting Functions Duplicate function names in different libraries can create confusion and lead to errors in R because when multiple packages define functions with the same name, R will prioritize one function over another. This can cause unintended behavior and errors if a different function from a different package to be executed. For example, if two packages define a function called filter(), and one is from dplyr and the other from stats, R might use one by default, potentially breaking the code or leading to incorrect results if the wrong version is applied. Managing these conflicts is essential for ensuring that the correct function is used in the desired context. Option 1: Using :: Syntax To specify which package’s function to use, you can use the :: syntax. For example, to use the select() function from dplyr, write dplyr::select(). This ensures you are explicitly calling the correct function from the right package. Option 2: Using the Conflict Package The conflict package in R is designed to help manage situations where two or more loaded packages have functions with the same name. When you load multiple packages that contain functions with identical names, R will prioritize one function over another, which can lead to confusion or errors in your analysis. For example, both amt and dplyr have a select(). The conflict package provides tools to manage these conflicts explicitly and prevent unexpected behavior. library(conflicted) conflict_prefer(&quot;select&quot;, &quot;dplyr&quot;) # This will prefer the select() function ## [conflicted] Will prefer dplyr::select over any other ## package. # from the dplyr package. 12.6 Use the Help ? Function! In R, you can use the ? function to access R documentation for functions, packages, or datasets. For example, ?select will bring up the documentation for the select() function. If you want information about a specific package, you can use ?package_name, such as ?dplyr, to view its documentation. This is a quick way to learn about function arguments, usage, and examples directly within R. 12.7 Google A quick Google search often leads to answers, and most R packages include vignettes or documentation to explain how functions work. For example, if you’re unsure how to use the seq function in R to generate a sequence with a step size of 0.5, you could search for “how do I use the seq function in R to generate a sequence of numbers by 0.5?” It’s important to specify that you’re working with R and clearly describe your problem to get better results. Another invaluable resource is Stack Overflow, a community-driven Q&amp;A website where developers and data scientists share knowledge. On Stack Overflow, you can search for similar issues, or if your question hasn’t been asked yet, you can post your own. 12.8 AI AI (e.g. ChatGPT) can be a valuable tool for debuggin code, but it’s important to remember that it’s not always correct. Relying too heavily on AI can also hinder your ability to develop and strengthen your coding skills. "],["readable-r.html", "Chapter 13 Making Readable R Code 13.1 Outlining R Scripts 13.2 Pseudocoding 13.3 Making Readable R Code", " Chapter 13 Making Readable R Code 13.1 Outlining R Scripts R scripts can get long, and it can get a bit unwieldy to navigate between different sections of your script. One neat way to outline your script is by using comment headers as bookmarks. This can be accomplished by either putting ---- or #### after a commented line. # 1. Section ---- ## a. Subsection #### ### i. Sub-subsection ---- 13.2 Pseudocoding Pseudocoding is basically a way to map out your code by writing down the logic in plain English. It helps you figure out what you’re trying to do, organize your ideas, and spot potential issues before you actually start coding. It’s like sketching a rough draft before creating the final version. Pseudo coding can also be used to identify problematic code. To write pseudocode: Define the problem: Understand what you want to solve. Outline the steps: Break down the problem into logical, sequential steps. Use simple language: Write instructions in a clear and understandable format, avoiding technical jargon. Focus on logic: Focus on the flow of data, control structures (loops, conditionals), and key operations. 13.3 Making Readable R Code Start each script with a brief description of what it does, who wrote it, and the last date it was edited. Then load all required packages, define functions, and set any variables used consistently throughout your script. Example: If you are going to be exporting many plots during the course of your script, you could set a variable to the output folder. Setting variables allows you to not have repeat code. output_plots &lt;- \"output/plots/\" You can source functions from a separate script using source(). Remember what working directory you are in when sourcing a script. Use comments to mark off sections of code. Outline your script Name and style code consistently. Spacing can make code more readable, but it’s really up to personal preference. Break code into small, discrete pieces. Think about the best way to organize your directory given your objectives. I often have sub folders for data, output, and docs. Start with a clean environment instead of saving the work space. Consider using version control (i.e. Github). "],["class-wrap-up.html", "Chapter 14 Class Wrap Up", " Chapter 14 Class Wrap Up Artwork by Allison Horst We hope that you have picked up some useful skills in this IntroR course and are motivated to keep learning R. If you run into questions down the road, feel free to reach out to either one of us. We’re also planning a second workshop on spatial data manipulation and analysis, which will include: Wrangling Spatial Data using the simple feature package Wrangling dates and times Mapping spatial data (e.g. leaflet, baseR, etc.) Implementing and exploring key differences between Kaplan Meier and Cox Proportional Hazard survival analyses. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
