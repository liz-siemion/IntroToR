[["control.html", "Chapter 9 Control Structures 9.1 Loops 9.2 Troubleshooting For-loops 9.3 if, else, and ifelse statements 9.4 next and break 9.5 Keeping track of loop", " Chapter 9 Control Structures Control structures are important tools for writing clear and efficient code by using conditional statements and repeated actions. Common control structures in R include if, else, and ifelse() for making decisions, and loops for, while, and repeat for running code multiple times. For example, if statements run code only when a condition is true, while for loops repeat actions for each item. 9.1 Loops There are three main types of loops: for (most common), while, and repeat. For loops are not always the most efficient way to perform repetitive tasks. In many cases, vectorized operations (e.g. apply functions) are faster and more efficient. Vectorized operations apply to entire vectors (or arrays) at once, whereas for loops iterate through individual elements sequentially. We will not be covering vectorization operations in this course, but it is good to be aware that they exist. for(i in 1:n) { # n = number of times you run the loop # execute a task } # end loop It’s good practice to indent the code inside your loop and add a comment at the end to mark that the loop is finished. This becomes especially helpful when you have nested loops, as it makes your code easier to read and understand. for(i in 1:10) { print(i + 3) # indented code chunk } # comment that this is the end of the ith loop ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ## [1] 11 ## [1] 12 ## [1] 13 When using a for loop, you often need to store the results from each iteration. Start by creating an empty object before the loop begins. Inside the loop, assign each result to a specific index of that object. To aid in debugging, use the cat() function to print the current iteration number. This allows you to track the loop’s progress and easily identify issues by running it step by step. # create empty vector of desired dimensions my_vector &lt;- rep(NA, length = 10) for(i in 1:10) { cat(i) # print current iteration of loop my_vector[i] &lt;- i + 3 * (i-1) # save output in the ith position of my_vector } # end i loop ## 12345678910 my_vector ## [1] 1 5 9 13 17 21 25 29 33 37 9.2 Troubleshooting For-loops Troubleshooting for-loops can be tricky. Below are a few hints for troubleshooting code in a for-loop. Check loop syntax Print iteration progress Check object dimensions Check variable types Avoid indexing errors Check loop boundaries Validate conditional statements Use try-catch for errors Ensure proper object initialization Check for missing values Example: Converting Sheep Weight from Kilograms to Pounds Let’s start by creating a sample capture data frame that includes sheep IDs and their weight in kilograms. capt &lt;- data.frame(animal_id = c(&quot;S431&quot;, &quot;S488&quot;, &quot;S490&quot;, &quot;S511&quot;), weight_kg = c(43, 55, 48, &quot;50kg&quot;)) Next, we’ll run a for loop to convert the weight from kilograms to pounds. Before doing so, we need to create a new column in the data frame to store the converted weight in pounds. capt$weight_lb &lt;- NA # R automatically assigns each of the 4 rows as NA Now, here’s a for loop that attempts to transform the weight from kilograms to pounds. This loop has two issues that we need to address: for (i in 1:nrow(capt)) { pounds &lt;- capt$weight_kg[i] * 2.20462 capt$weight_lb &lt;- pounds } ## Error in capt$weight_kg[i] * 2.20462: non-numeric argument to binary operator Issue 1: Error in the First Iteration It looks like the loop threw an error. To find where the error occurred, we can print the current iteration value (i), which will help identify the problem: i ## [1] 1 The error occurs in the first iteration. To debug further, we can execute the loop’s code step by step. Let’s start with the first line: pounds &lt;- capt$weight_kg[i] * 2.20462 ## Error in capt$weight_kg[i] * 2.20462: non-numeric argument to binary operator Issue 2: Non-Numeric Data in weight_kg The error occurs because the weight_kg column contains a non-numeric entry: “50kg”. Let’s check the data type of capt$weight_kg: class(capt$weight_kg) ## [1] &quot;character&quot; Because the weight_kg column is of character type, we cannot perform an arithmetic operation, and the code throws an error. To fix this, we need to convert the weight_kg column to numeric. capt$weight_kg_new &lt;- as.numeric(capt$weight_kg) ## Warning: NAs introduced by coercion Looks like an NA was thrown. Let’s check the original weight_kg column to understand why: capt$weight_kg ## [1] &quot;43&quot; &quot;55&quot; &quot;48&quot; &quot;50kg&quot; The fifth row contains “50kg”, which causes the entire column to be treated as character data. To fix this, we can remove any alphabetic characters from the weight_kg column using regular expressions (regex). Although we won’t cover regex in detail here, it’s a useful tool for cleaning data. capt$weight_kg &lt;- gsub(&quot;[A-Za-z]&quot;, &quot;&quot;, capt$weight_kg) capt$weight_kg &lt;- as.numeric(capt$weight_kg) Issue 3: Incorrect Weight Conversion in the Loop Now that the first issue is resolved, let’s try running the for loop again: for (i in 1:nrow(capt)) { pounds &lt;- capt$weight_kg[i] * 2.20462 capt$weight_lb &lt;- pounds } capt$weight_lb ## [1] 110.231 110.231 110.231 110.231 This time, the loop runs, but it appears that the same weight value was applied to all rows. Let’s debug this by running through the loop step by step. First, we’ll reset the weight_lb column to NA and set i = 1 to check the output for the first row: capt$weight_lb &lt;- NA # R automatically assigns each of the 4 rows as NA for (i in 1:nrow(capt)) { pounds &lt;- capt$weight_kg[i] * 2.20462 capt$weight_lb &lt;- pounds } Issue 4: Forgetting to Index the weight_lb Column Correctly The problem is that we forgot to properly index the capt$weight_lb column with i to ensure the calculated pounds value is assigned to the correct row. Let’s fix the loop by updating the assignment to capt$weight_lb[i]: capt$weight_lb &lt;- NA # Reset the weight_lb column to NA # Correct the loop for (i in 1:nrow(capt)) { pounds &lt;- capt$weight_kg[i] * 2.20462 capt$weight_lb[i] &lt;- pounds # Use indexing to assign pounds to the correct row } Additional Debugging Tip: Experiment with Iteration Values A helpful debugging trick is to manually set the value of i to different numbers to observe how the behavior of the loop changes with different data. For example: i &lt;- 2 # Test with a specific iteration capt$weight_kg[i] * 2.20462 # Check the result for the second iteration ## [1] 121.2541 This allows you to understand how the loop behaves with specific input values. EXERCISE Write a for loop that runs for 10 iterations, adding 3 to the loop index during each iteration 9.3 if, else, and ifelse statements If, else, and ifelse statements allow you to control the flow of your code by making decisions based on specific conditions. This can be particularly helpful in for loops, where you might want to execute different actions depending on the iteration. For instance, conditional statements allow you to alternate between different operations or calculations during each iteration of a loop. This provides flexibility, enabling you to adjust the behavior of your code based on dynamic factors like the loop index or other variables. Below is an example where a for loop and ifelse statement are used to store a logical value in a vector if a randomly generated number is less than or equal to 50. # create vector of length 10 with random numbers my_vect &lt;- sample(x = 1:100, size = 15) output_vect &lt;- NULL for (i in 1:length(my_vect)) { if(my_vect[i] &lt;= 50) { output_vect[i] &lt;- TRUE } else{ output_vect[i] &lt;- FALSE } } my_vect ## [1] 48 70 28 24 55 74 4 6 11 18 2 73 75 69 22 output_vect ## [1] TRUE FALSE TRUE TRUE FALSE FALSE TRUE TRUE TRUE TRUE TRUE FALSE ## [13] FALSE FALSE TRUE You can also use the ifelse() statement for a conditional statement. species &lt;- c(&quot;snbs&quot;, &quot;lion&quot;, &quot;deer&quot;, &quot;deer&quot;) # Use ifelse to label values as &quot;small&quot; or &quot;large&quot; result &lt;- ifelse(species %in% c(&quot;snbs&quot;, &quot;deer&quot;), &quot;prey&quot;, &quot;predator&quot;) result ## [1] &quot;prey&quot; &quot;predator&quot; &quot;prey&quot; &quot;prey&quot; Why use ifelse() instead of if-else? While both ifelse() and traditional if-else statements perform conditional logic, ifelse() is often preferred when you need to apply conditions element-wise (e.g., to vectors or columns in a data frame) and so is better for vectorized operations. For example, ifelse() is faster and simpler when you want to apply a condition across an entire vector or column at once, without having to explicitly loop over each element. In contrast, a traditional if-else statement is typically used when you need more complex or multi-step conditions and is better suited for situations that involve single-value conditional logic within control structures like loops. 9.4 next and break In a for loop, the next and break commands provide control over the loop’s behavior: next: Skips the current iteration and moves to the next one. It’s useful when you want to bypass certain iterations based on a condition without exiting the entire loop. for (i in 1:5) { if (i == 3) next # Skip iteration when i is 3 print(i) } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 break: Immediately exits the loop, stopping further iterations. This is useful when you want to terminate the loop early based on a specific condition. for (i in 1:5) { if (i == 3) break # Exit the loop when i reaches 3 print(i) } ## [1] 1 ## [1] 2 Both next and break give you fine-grained control over loop behavior, allowing you to skip unnecessary steps or stop the loop early when certain conditions are met. 9.5 Keeping track of loop You can have R print something out at each loop iteration. This is particularly useful with nested loops and determining where you have data problems, i.e. unexpected results in the middle of a loop because of a data anomaly. For this you can insert a cat() function (which prints to the console, so you can see what is happening in real time) # Example for (x in 1:10) { cat(&quot;\\nIteration n =&quot;, x, &quot;is being executed now&quot;) x_sqrt &lt;- sqrt(x) cat(&quot;\\nThe square root of&quot;, x, &quot;=&quot;, x_sqrt, &quot;\\n&quot;) } ## ## Iteration n = 1 is being executed now ## The square root of 1 = 1 ## ## Iteration n = 2 is being executed now ## The square root of 2 = 1.414214 ## ## Iteration n = 3 is being executed now ## The square root of 3 = 1.732051 ## ## Iteration n = 4 is being executed now ## The square root of 4 = 2 ## ## Iteration n = 5 is being executed now ## The square root of 5 = 2.236068 ## ## Iteration n = 6 is being executed now ## The square root of 6 = 2.44949 ## ## Iteration n = 7 is being executed now ## The square root of 7 = 2.645751 ## ## Iteration n = 8 is being executed now ## The square root of 8 = 2.828427 ## ## Iteration n = 9 is being executed now ## The square root of 9 = 3 ## ## Iteration n = 10 is being executed now ## The square root of 10 = 3.162278 EXERCISE Create a data frame Create a data frame that includes the following columns: deer_id: a unique identifier for each deer (as a character) month: the month the data was recorded (as a number from 1 to 12) year: the calendar year of the observation (as a number) Add an animal year column using a for loop and ifelse Using a for loop, add a new column called animal_year to the data frame. If the month is between May (5) and December (12), add 1 to the year If the month is between January (1) and April (4), keep the year unchanged Use an ifelse() statement inside the loop to apply this logic. BONUS: Use the cat() command to print what iteration is being executed in the for loop, the calendar year, and the new animal year is. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
