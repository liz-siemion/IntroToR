[["using-r.html", "Chapter 5 Using R 5.1 Installing Packages 5.2 Using Comments 5.3 Functions 5.4 Use R as a calculator 5.5 Use R to compare things 5.6 Use R to assign objects 5.7 Data Types (Modes) 5.8 Data Structure Classes 5.9 Indexing", " Chapter 5 Using R 5.1 Installing Packages Sometimes you will want to use tools that are not built into the baseR code. You can download these tools from R repositories as packages. A package is a collection of functions, data, and documentation bundled together for a specific function. An R package can help with tasks such as data visualization, statistical modeling, or data cleaning. You can install an R package through the RStudio interface, or through entering code into the console. install.packages(&quot;amt&quot;) # install a new package library(amt) # call a package you previously downloaded EXERCISE Load Tidyverse package using RStudio Select Packages Select Install Type tidyverse Select Install Bonus: Install tidyverse in the code editor using the example code above. We will go over what tidyverse is later on in this course If two different packages contain functions with the same name, R will mask one with the other based on the order they are loaded. To avoid confusion, you can explicitly tell R which package to use by using the package::function() format. For example, the filter() function exists in both stats and dplyr packages. If you specifically want the version from dplyr, you can write dplyr::filter() in your code. We will talk more about this later on. 5.2 Using Comments Use the # to tell R you are making a comment. Comments are used to explain code and allow someone unfamiliar with your code to follow more easily. Commenting can also be used to prevent R from running specific lines of code since R ignores anything that follows the # mark. # 567*5 tells R that 567*5 is a comment, and so R knows not to execute this line of code. Sometimes you want to comment out large sections of code, and this can be done using control + shift + c on windows or command + shift + c on a macbook. EXERCISE Create a new script (File &gt; New File &gt; R Script) In the first line, type # Intro R On line 2, type 1 + 1 Select Run in the upper right corner of the console. You can also use the shortcut control + enter on Windows and command + enter on a Macbook. If the keyboard shortcuts aren’t working, navigate to Tools &gt; Modify Keyboard Shortcuts , type Run Current Line or Section into the search bar, double-click the shortcut, remove the current key combination, and enter your preferred shortcut. 5.3 Functions A function is a defined script that is used to accomplish a particular task. Functions use an input to give a desired output. R provides built-in functions, such as mean(), sum(), and plot(), which perform commonly used operations. Every function has arguments that determine what kind of inputs are needed to make the function run. The inputs in a function are called arguments. Arguments: information that goes inside the parenthesis to tell the function what to do. For example, when we used the seq function above, the arguments are from = 1, to = 10, and by = 0.1. Pass: We pass a value to a function argument. Above, we pass the value 1 to the argument from, and the value 10 to the argument to and the value 0.1 to the argument by Return: This is the terminology to say that the function gives us an output. So with the seq(from = 1, to = 10, by = 0.1), the function returns a sequence of numbers The order of arguments in a function call matters, especially when you don’t name them. To avoid confusion, it’s often helpful to explicitly name the arguments. You can use the help system to check the correct usage of a function. For example, to learn more about the rep() function, you can type ?rep in the Console. Additionally, you can define your own functions to solve specific problems and use them across multiple analyses. Functions are an essential part of R programming, as they allow for cleaner, more efficient, and modular code. Although we won’t be covering custom functions in this course, it’s important to note that creating your own functions is a common and useful practice in programming. function_name &lt;- function(arg1, arg2) { # arg1 and arg2 are inputs # Code that processes the inputs result &lt;- arg1 + arg2 return(result) # return() provides the output of the function } EXERCISE Use the ? function to look up the seq() function. Why does seq(from = 1, by = 3) return a sequence successfully, while seq(from = 40, by = 3) results in an error? What is causing the difference in behavior? 5.4 Use R as a calculator Remember, order of operations matters. The order is the same as you learned back in school. From highest to lowest precedence: Operator Symbol(s) Description Parentheses ( ) Controls the order of operations Exponents ^, ** Raises a number to a power Divide / Division Multiply * Multiplication Add + Addition Subtract - Subtraction 1 + 100 ## [1] 101 3 + 5 * 2 # performs multiplication before addition ## [1] 13 (3 + 5) * 2 # performs addition in () before multiplication ## [1] 16 2/10000 ## [1] 2e-04 2^3 ## [1] 8 5.5 Use R to compare things To compare things in R, we use logical operators. Below is a brief list. Operator Meaning == is equal to &gt; greater than &lt; less than &gt;= greater than or equal to &lt;= less than or equal to ! not | or %in% is contained in Let’s go through a few examples of using logical operators. Notice how R evaluates each of these lines of code as TRUE or FALSE. We are essentially asking R if the above comparison is TRUE or FALSE. We will go over %in% in the data organization section of this class. 1 == 9 # equality (note two equals signs, read as &quot;is equal to&quot;) ## [1] FALSE 1 != 1 # inequality (read as &quot;is not equal to&quot;) ## [1] FALSE 1 &lt; 2 # less than ## [1] TRUE 1 &lt;= 1 # less than or equal to ## [1] TRUE EXERCISE In your code editor, enter the following lines of code. Then run them to view each line of code’s output in your console. 67 * 9 7 + 9 + 10 4399 - 871 * (9 + 1) Evaluate whether the following logical conditions are TRUE or FALSE (380*3) == (190*6) 567 &gt; 890 30 &gt;= (27 + 1 + 2) Bonus: What is wrong with the following code? Type 87(9 + 1) into your console Execute that specific line of code by placing the cursor on that line and selecting Run. What error do you see? What do you think is happening? How might you fix this? 5.6 Use R to assign objects Objects are a bit of an abstract concept. All you really need to know for now is that objects are things that we make in R that can take on a variety of structures with different data types, and when we assign them a name, they get saved in our global environment. They are data structures with associated data attributes. Object assignment allows us to assign a variable name to the object for later use. This helps prevent writing redundant code. We assign an object to a variable using the assignment arrow &lt;- or the = so that R knows that x is an object that we can use. So when we run, x &lt;- 6, it reads make x contain 6 It’s recommended to use the &lt;- since the = can get mixed up with assigning values to function arguments (more on this later). Once we assign an object to a variable, it is stored in our global environment (upper right hand panel of RStudio). x &lt;- 1/40 # here we are telling R to assign 1/40 to the variable x so that it recognizes x as an object in our global environment x ## [1] 0.025 x = 24 # variables can easily be re-assigned/over-written y &lt;- x * 2 rm(y) # you can also remove objects from the environment 5.6.1 Variable names Variable names can contain letters, numbers, underscores and periods. They CANNOT start with a number OR contain spaces (at all). Remember that R is case sensitive. A few different conventions for longer variable names: periods.between.words underscores_between_words camelCaseToSeparateWords Your choice of convention is up to you, JUST BE CONSISTENT. EXERCISE Assign 1+56 to a variable called x1_a Assign sqrt(24) to a variable called x1_b Bonus: Chained assignments. What happens when you execute x3.c &lt;- y3.c &lt;- 9/10 into your console? Are x3.c and y3.c different or equal values? 5.7 Data Types (Modes) There are 6 main classes of common data modes (i.e. data types): numeric, character, logical, integer, complex, and factor. Data modes refers to the basic type of data stored in an object. For example, numeric mode stores numbers (integers or decimals), and character mode stores text. We typically only use factor, numeric, character, and logical data modes. Mode Description Example factor Categorical data “Sheep”, “Lion”, “Deer” numeric Numbers (includes integers and decimals) 3.14, 42 character Text strings “Lion180” logical TRUE or FALSE values TRUE, FALSE To ask R what class a data mode or object is, we use the class() function. class(1.11) # numeric: any real number class(1L) # integer: any integer. The L suffix forces the number to be an integer class(TRUE) # logical: binary TRUE or FALSE # You can have data that look essentially the same, but have different classes. class(&#39;1&#39;) # character: words; &quot;&quot; denote words class(1) # numeric; any real number class(factor(&quot;1a&quot;)) # factor: denotes categorical variables, they can be words or numbers You can coerce to a desired data type, as long as they follow the rules using the functions as.&lt;desired data type&gt; Coercian Hierarchy from general to specific: Logical -&gt; Numeric -&gt; Factor -&gt; Character logical (least general, cannot turn turn character or numeric into a logical type without correctly specifying the value) numeric (can read integer and logical types as numbers) character (most general: anything can be turned into a character by adding “quotes”) # Convert from numeric to integer a &lt;- 45.6 class(a) ## [1] &quot;numeric&quot; # Convert from numeric to character a_character &lt;- as.character(a) class(a_character) ## [1] &quot;character&quot; # Create factored variable lion &lt;- factor(c(&quot;194&quot;), levels = c(&quot;194&quot;)) lion # print value into console ## [1] 194 ## Levels: 194 as.numeric(lion) # coerced to numeric ## [1] 1 as.character(lion) # coerced to character ## [1] &quot;194&quot; as.numeric(as.character(lion)) # coerced to character, then numeric ## [1] 194 A common mistake in R is using data of the wrong type. In the example below, an error occurs because R cannot convert a character value into a numeric one. It’s important to ensure that the data you’re working with is of the correct type. Also, remember that each column in a data frame should contain values of the same type. # convert from character to numeric b &lt;- &quot;banana&quot; b_numeric &lt;- as.numeric(b) ## Warning: NAs introduced by coercion EXERCISE Assign \"S437\" to a variable called “sheep”. Make sure to include the \"\". What type of data class is sheep? Create an object with a value of 45. Coerce to a character class using as.character(). Execute S1 &lt;- as.numeric(as.character(1)) and S2 &lt;- as.logical(as.numeric(\"1\")). Do the values change? Why or why not? Think about this answer in the context of the coercian hierarchy. Bonus: What happens when you execute sheep &lt;- S437 without \"\"? Explain the error. 5.8 Data Structure Classes Remember when we talked about objects as data with attributes? Well, R offers several ways to store data, depending on what kind of structure you need. The most common types are vectors, data frames, and lists. Each of these can store different types of information and are useful in different contexts when working with data. Think of them as different types of containers for data that are designed to hold and organize data in specific ways. We will be discussing Scalar, Vector, Data Frames, Matrices, and Lists. Below is a summary of each of these data structures, and we will also go through each of these individually. Data Structure Description Can Contain Different Types? Dimensions Example Scalar A single value (a vector of length 1) No 1 (length = 1) x &lt;- 42 Vector A sequence of elements of the same type No 1 (length &gt; 1) c(1, 2, 3) Data Frame Table-like structure with columns of equal length Yes (by column) 2 (rows × cols) data.frame(a = 1:3, b = c(\"x\", \"y\", \"z\")) Matrix 2D array with all elements of the same type No 2 (rows × cols) matrix(1:6, nrow = 2) List A collection of elements that can be of different types Yes 1 (named or not) list(name = \"A\", age = 25, scores = c(1,2,3)) 5.8.1 Scalar A vector has one element with length 1. x &lt;- 3 EXERCISE 5.8.2 Vector A vector in R is essentially a collection of items of the same basic data type. Each ‘thing’ in the vector is called an element. If you don’t choose the data type, it’ll default to logical; or, you can declare an empty vector of whatever type you like. You can also make vectors with explicit contents using the concatenate function c(). my.deer &lt;- c(&quot;GDL256&quot;, &quot;RVD1011&quot;, &quot;CDB567&quot;) my_vector &lt;- vector(length = 3) my_vector # this is a logical vector ## [1] FALSE FALSE FALSE num_vector &lt;- c(101, 222, 323, 435, 556) # numeric vector # what happens when we add elements of different data types to a vector? combine_vector &lt;- c(211, &quot;CDB678&quot;, TRUE) combine_vector ## [1] &quot;211&quot; &quot;CDB678&quot; &quot;TRUE&quot; class(combine_vector) ## [1] &quot;character&quot; R interprets the whole vector as character. It can’t make “banana” into a number but it can turn 2 and TRUE into text strings. This logic follows the coercian hierarchy. You can also assign NA values to a vector of defined length as well. R is able to handle missing values, and these missing values are given NA. When you read in an csv file with empty cells, R will assign these values as NA. A 0 is not the same as NA, since R treats 0 as a numeric data class. x &lt;- rep(NA, 10) x[1] &lt;- 0 # test if zero is NA is.na(x) ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE We can also make a series of numbers using : or the seq() function. my_series &lt;- 1:10 # just integers my_series ## [1] 1 2 3 4 5 6 7 8 9 10 # make series of numbers from 1 to 10 by increments of 0.1 my_seq &lt;- seq(from = 1, to = 10, by = 0.1) my_seq ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 ## [16] 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 ## [31] 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 ## [46] 5.5 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 ## [61] 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 8.0 8.1 8.2 8.3 8.4 ## [76] 8.5 8.6 8.7 8.8 8.9 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 ## [91] 10.0 EXERCISE 5.8.3 Lists A list in R is essentially an object with data that can be in different data types/modes. # list with numeric, character, and logical classes my_list &lt;- list(1, &quot;banana&quot;, TRUE) your_list &lt;- list(2, &quot;apple&quot;, FALSE) my_list ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;banana&quot; ## ## [[3]] ## [1] TRUE # we can also append to a list with c() like we did to a vector my_list &lt;- c(my_list, c(&quot;Lion171&quot;, &quot;S222&quot;)) The $ is called the operator, and it is used for indexing named elements in a list. It allows you to access part of a data object for extracting or subsetting data. my_lions &lt;- list(&quot;L211&quot;, c(&quot;L194&quot;, &quot;S789&quot;), &quot;L180&quot;) names(my_lions) # are names automatically assigned? Nope, so let&#39;s assign names with the names() function. ## NULL names(my_lions) &lt;- c(&quot;Lion211&quot;, &quot;LionsAndSheep&quot;, &quot;Lion180&quot;) my_lions$LionsAndSheep ## [1] &quot;L194&quot; &quot;S789&quot; If you wanted to index a specific element in the list, you could also use brackets # index second list [[2]] and second element [2] of the second list my_lions[[2]][2] ## [1] &quot;S789&quot; EXERCISE 5.8.4 Matrix A matrix in R is a two-dimensional data structure that stores elements of the same type (usually numbers). You can think of it like a spreadsheet or a table with rows and columns, but every value must be the same type (e.g., all numeric or all character). Matrices are useful when you want to perform mathematical operations on tables of numbers, like multiplying rows and columns, or applying functions across rows or columns. MyMatrix &lt;- matrix(1:6, nrow = 2, ncol = 3) MyMatrix ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 EXERCISE 5.8.5 Data Frames A data frame in R is a like a list or generalized matrix but with the constraints that: all list elements are vectors (i.e. they have 1 mode), all vectors have the same length all columns (the list elements) have names Essentially, imagine each column in the dataframe as a vector, and the dataframe is just a big list of all those vectors. Unlike actual lists however, in dataframes all of the columns/vectors MUST be the same length and have names. # Create vectors for each column sheep_id &lt;- c(&quot;S601&quot;, &quot;S602&quot;, &quot;S603&quot;) sex &lt;- c(&quot;F&quot;, &quot;M&quot;, &quot;F&quot;) age &lt;- c(4, 6, 3) capt_date &lt;- as.Date(c(&quot;2024-03-15&quot;, &quot;2024-03-16&quot;, &quot;2024-03-18&quot;)) capt_loc &lt;- c(&quot;Acrodectes Peak&quot;, &quot;Sawmill Canyon&quot;, &quot;Goodale Canyon&quot;) # Combine into a data frame capt_dat &lt;- data.frame( ID = sheep_id, Sex = sex, Age = age, CaptureDate = capt_date, CaptureLoc = capt_loc, stringsAsFactors = FALSE # Ensures character columns are maintained as characters (not factors) ) # View the data frame print(capt_dat) ## ID Sex Age CaptureDate CaptureLoc ## 1 S601 F 4 2024-03-15 Acrodectes Peak ## 2 S602 M 6 2024-03-16 Sawmill Canyon ## 3 S603 F 3 2024-03-18 Goodale Canyon EXERCISE 5.8.6 Other Object Types R includes many other object types that we won’t cover in detail during this course. For instance, spatial object types are used to represent and work with geographic data. The specific structure depends on the package ecosystem—most commonly the older sp system or the more modern, tidyverse-friendly sf package. 5.9 Indexing Indexing in R refers to the process of accessing specific elements from data structures like vectors, lists, or data frames. The type of indexing you use depends on the structure of your data and the task at hand, making it a versatile tool for data manipulation. To extract elements from a vector, use their index inside square brackets []. Indexing Method Description Example Positional Indexing Use numeric positions (1-based) to access elements in a vector, list, or data frame. my_vector[2] returns the 2nd element. Named Indexing Access elements by their name, making the code more readable. my_vector[\"b\"] returns the value associated with b. Logical Indexing Use a logical vector (TRUE/FALSE) to subset elements. Only elements corresponding to TRUE are selected. my_vector[c(TRUE, FALSE, TRUE)] returns elements where TRUE is present. Range Indexing Extract a range or sequence of elements using a colon or vector of indices. my_vector[2:4] returns elements from positions 2 to 4. Negative Indexing Exclude elements by using negative indices. my_vector[-2] excludes the 2nd element. Indexing with which() Find the indices of elements that satisfy a condition, and use those indices for subsetting. which(my_vector &gt; 20) returns indices where the values are greater than 20. 5.9.1 Numerical Indexing This method involves using the position of elements in a vector, list, or other data structures. R uses 1-based indexing, meaning the first element has an index of 1, not 0 (as in some other programming languages like Python or C). lion_list &lt;- c(&quot;194&quot;, &quot;228&quot;, &quot;267&quot;, &quot;272&quot;) lion_list[1] # extract first element out of the lion_list vector ## [1] &quot;194&quot; lion_list[4] # extract 4th element out of the lion_list vector ## [1] &quot;272&quot; lion_list[c(2:4)] # extract elements 2 to 4 from the my_seq vector ## [1] &quot;228&quot; &quot;267&quot; &quot;272&quot; 5.9.2 Named Indexing You can also extract elements by name rather than by index. Using names for indexing is particularly useful when you want to avoid relying on numeric positions, which may change as new data is added. horn_length &lt;- c(10, 30, 90, 50, 30) # create vector of horn lengths names(horn_length) &lt;- c(&quot;S4&quot;, &quot;S567&quot;, &quot;S489&quot;, &quot;S488&quot;, &quot;S89&quot;) # assign sheep names to vector # we can also name a vector &#39;on the fly&#39; horn_length &lt;- c(S4 = 5.4, S567 = 6.2, S489 = 7.1, S488 = 4.8, S89 = 7.5) horn_length[c(&quot;S489&quot;, &quot;S488&quot;)] ## S489 S488 ## 7.1 4.8 5.9.3 Logical Indexing Since comparison operators (e.g. &gt;, &lt;, ==) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one. This involves using logical vectors (TRUE/FALSE) to index elements. The logical vector must be of the same length as the data structure you’re indexing. Only elements corresponding to TRUE are selected. horn_length[horn_length &gt; 30] # this statement first evaluates horn_length &gt; 7, generating a logical vector c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of horn_length corresponding to the TRUE values. ## named numeric(0) 5.9.4 Range or Sequence Indexing You can extract a range or sequence of elements using a colon : to specify a range or a vector of indices. horn_length[1:3] ## S4 S567 S489 ## 5.4 6.2 7.1 5.9.5 Negative Indexing Negative indexing is used to exclude elements from a data structure. When you use a negative index, R excludes the element at that specific position. Note that negative indexing only applies to numeric positions, not named elements. horn_length[-2] ## S4 S489 S488 S89 ## 5.4 7.1 4.8 7.5 # we can skip multiple elements horn_length[c(-1, -2)] ## S489 S488 S89 ## 7.1 4.8 7.5 # or horn_length[-c(1,5)] ## S567 S489 S488 ## 6.2 7.1 4.8 # a common mistake would be to ask R x[-1:3] # but there isn&#39;t a negative first row # But remember the order of operations. # : is really a function. It takes its first argument as -1, # and its second as 3, so generates the sequence of # numbers: c(-1, 0, 1, 2, 3). horn_length[-(1:3)] ## S488 S89 ## 4.8 7.5 # To remove elements from a vector, we need to assign the result # back into the variable: horn_length &lt;- horn_length[-4] horn_length ## S4 S567 S489 S89 ## 5.4 6.2 7.1 7.5 5.9.6 Which Indexing The which() function returns the indices of elements that satisfy a given condition (useful in combination with logical operations). EXERCISE 5.9.7 Indexing different data types Different object types in R require distinct indexing syntax, as each type has its own structure and behavior. For instance, vectors are indexed using [], while lists require [[]] to extract individual elements. Data frames can be subsetted using both [] and [[]], but the syntax varies depending on whether you’re accessing rows, columns, or individual elements. Understanding the proper indexing method for each object type is crucial for effectively manipulating and extracting data in R. Data Structure Indexing with [] Indexing with [[]] Description Vector my_vector[2] - Accesses the 2nd element. Not applicable (use [] for vectors). [] returns a subset (vector), and [] is used to extract individual elements by their position. Data Frame my_df[2, ] - Accesses the 2nd row (returns a data frame). my_df[[2]] - Accesses the 2nd column (returns a vector). [] keeps the result as a data frame, while [[]] extracts a specific column or element. Matrix my_matrix[2, 3] - Accesses the element in the 2nd row and 3rd column. Not applicable (use [] for matrices). [] is used to index both rows and columns, but [[]] is not used with matrices. List my_list[2] - Returns the 2nd element of the list (as a list). my_list[[2]] - Returns the 2nd element of the list (as the actual object, not as a list). [] returns a sublist, while [[]] extracts the actual object at that index. List of Lists my_list_of_lists[2] - Returns the 2nd list in the list of lists (as a list). my_list_of_lists[[2]] - Returns the 2nd list (the entire list, not just an element). [] returns a sublist, while [[]] extracts the entire second list when using a list of lists. Nested List my_list[[2]][[2]] - Returns the 2nd element of the 2nd list in the list of lists (after first subsetting). my_list[[2]][[2]] - Extracts the 2nd element from the 2nd list in the list. [] can be used to subset lists, and [[]] extracts elements within the nested list structure. EXERCISE "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
